# Marine InVEST: Coastal Vulnerability Model
# Authors: Gregg Verutes, Greg Guannel, Jeremy Davies 
# Coded for ArcGIS 9.3 and 10
# 02/16/11

# import modules
from win32com.client import Dispatch
from FetchTools import fetchGeoprocessor
import sys, string, os, datetime, array, time, datetime
from math import *
import arcgisscripting
import fpformat, operator, numpy
from scipy import stats

# create the geoprocessor object
gp = arcgisscripting.create()

# set output handling
gp.OverwriteOutput = 1
# check out extensions
gp.CheckOutExtension("spatial")
gp.CheckOutExtension("management")
gp.CheckOutExtension("analysis")
gp.CheckOutExtension("conversion")

# error messages
msgArguments = "\nProblem with arguments."
msgCheckGeom = "\nError checking the geometry of inputs."
msgCheckDatum = "\nError checking the datum of inputs."
msgAOIcshelf = "\nError checking that the AOI input intersects the continental shelf."
msgDataPrep = "\nError preparing the data inputs."
msgWindCalc = "\nError reading in wind data."
msgFetchCalc = "\nError calculating fetch distances."
msgExpIndexParameters = "\nError reading in exposure index parameters."
msgBiogenicHab = "\nError incorporating biogenic habitat."
msgGeomorph = "\nError incorporating geomorphology."
msgDistShelf = "\nError calculating distance to shelf."
msgSeaLevRise = "\nError assigning input for expected sea level rise."
msgCombineIndex = "\nError combining results for exposure index."
msgPopulationCalcs = "\nError extracting coastal population."
msgExposureIndex = "\nError calculating coastal exposure index."

try:
    try:
        # get parameters
        parameters = []
        now = datetime.datetime.now()
        parameters.append("Date and Time: "+ now.strftime("%Y-%m-%d %H:%M"))
        gp.workspace = gp.GetParameterAsText(0)
        parameters.append("Workspace: "+ gp.workspace)
        gp.scratchWorkspace = gp.GetParameterAsText(0)
        parameters.append("Scratch Workspace: "+ gp.scratchWorkspace)
        landPoly = gp.GetParameterAsText(1)
        parameters.append("Land Polygon: "+ landPoly)
        landLine = gp.GetParameterAsText(2)
        parameters.append("Land Polyline: "+ landLine)
        areaFilter = gp.GetParameterAsText(3)
        parameters.append("Land Area Filter (kilometers squared): "+ areaFilter)
        AOI = gp.GetParameterAsText(4)
        parameters.append("Area of Interest (AOI): "+ AOI)
        cellsize = gp.GetParameterAsText(5)
        parameters.append("Cell Size (meters): "+ cellsize)
        projection = gp.GetParameterAsText(6)
        parameters.append("Projection: "+ projection)
        IndexParameters = gp.GetParameterAsText(7)
        parameters.append("Index Parameters: "+ IndexParameters)
        globalPop = gp.GetParameterAsText(8)
        parameters.append("Population Raster: "+ globalPop)
        kelp = gp.GetParameterAsText(9)
        parameters.append("Kelp: "+ kelp)
        eelgrass = gp.GetParameterAsText(10)
        parameters.append("Seagrass: "+ eelgrass)
        SeaLevRise = gp.GetParameterAsText(11)
        parameters.append("Polygon Indicating Net Rise or Decrease: "+ SeaLevRise)
        comarg = gp.GetParameterAsText(12)
        parameters.append("Continental Shelf: "+ comarg)
        Wind8minAvg = gp.GetParameterAsText(13)
        parameters.append("Wind Vector List "+ Wind8minAvg)
        shorezone = gp.GetParameterAsText(14)
        parameters.append("Shoreline Type: "+ shorezone)
    except:
        raise Exception, msgArguments + gp.GetMessages(2)
        
    # check and create folders
    try:
        thefolders=["intermediate", "Output"]
        for folder in thefolders:
            if not gp.exists(gp.workspace + folder):
                gp.CreateFolder_management(gp.workspace, folder)
    except:
        raise Exception, "Error creating folders"

    # intermediate and output directories
    outputws = gp.workspace + os.sep + "Output" + os.sep
    interws = gp.workspace + os.sep + "intermediate" + os.sep

    # prep variables
    landLine_clip = interws + "landLine_clip.shp"
    coast_select = interws + "coast_select.shp"
    coast_select_prj = interws + "coast_select_prj.shp"
    coast_rst = interws + "coast_rst"
    landPoly_clip = interws + "landPoly_clip.shp"
    coastPoly_rst = interws + "coastPoly_rst"
    aoi_prj = interws + "aoi_prj.shp"
    aoi_rst = interws + "aoi_rst"
    landsea = interws + "landsea"
    landsea_rst = interws + "landsea_rst"
    costsurf = interws + "costsurf"
    costsurf_e = interws + "costsurf_e"
    pop_prj = interws + "pop_prj"
    coast_pop_rc = interws + "coast_pop_rc"

    # exposure index variables
    veg_merge = interws + "veg_merge"
    veg_rc = interws + "veg_rc"
    kelp_prj = interws + "kelp_prj.shp"
    kelp_rst = interws + "kelp_rst"
    eelg_prj = interws + "eelg_prj.shp"
    eelg_rst = interws + "eelg_rst"
    sz_prj = interws + "sz_prj.shp"
    sz_rst = interws + "sz_rst"
    sz_e = interws + "sz_e"
    sz_rc = interws + "sz_rc"
    aoi_lyr = interws + "aoi_lyr.lyr"
    comarg_lyr = interws + "comarg_lyr.lyr"
    comarg_prj = interws + "comarg_prj.shp"
    comarg_rst = interws + "comarg_rst"
    costdist = interws + "costdist"
    costdist_rc = interws + "costdist_rc"
    slr_prj = interws + "slr_prj.shp"
    slr_rst = interws + "slr_rst" 
    slr_rc = interws + "slr_rc" 

    # output variables
    coastPoly_prj = outputws + "coastPoly_prj.shp"
    coast_pop = outputws + "coast_pop"
    coast_pop_Pts = outputws + "coast_pop_Pts.shp"
    exp_index = outputws + "exp_index"
    coast_vuln = outputws + "coast_vuln"

    # set each index as false, initially and then check inputs
    WindExp = "false"
    Biogenic = "false"
    DistShelf = "false"
    SeaLevChange = "false"

    if Wind8minAvg:
        WindExp = "true"
    if kelp or eelgrass:
        Biogenic = "true"
    if comarg:
        DistShelf = "true"
    if SeaLevRise:
        SeaLevChange = "true"
        
    ##############################################
    ###### COMMON FUNCTION AND CHECK INPUTS ######
    ##############################################

    # check that scratch workspace exists
    if gp.ScratchWorkspace == "":
        gp.AddError("A scratch workspace must be defined in you Environment Settings for this script to function properly.")
        raise Exception

    def checkGeometry(thedata, Type, Message):
        if gp.Describe(thedata).ShapeType <> Type:
            raise Exception, "\nInvalid input: "+thedata+"\n"+Message+" must be of geometry type "+Type+"."

    # check datum
    def checkDatum(thedata):
        desc = gp.describe(thedata)
        SR = desc.SpatialReference
        if SR.Type == "Geographic":
            strDatum = SR.DatumName         
        else:
            gp.OutputCoordinateSystem = SR
            strSR = str(gp.OutputCoordinateSystem)
            gp.OutputCoordinateSystem = ""
            n1 = strSR.find("DATUM[\'")
            n2 = strSR.find("\'",n1+7)
            strDatum = strSR[n1+7:n2]
        if strDatum == "D_WGS_1984":
            pass
        else:
            gp.AddError(thedata+" is not a valid input.\nThe model requires data inputs and a projection with the \"WGS84\" datum.\nPlease review InVEST FAQ guide on how to reproject datasets.")
            raise Exception

    # add field function
    def AddField(FileName, FieldName, Type, Precision, Scale):
        fields = gp.ListFields(FileName, FieldName)
        field_found = fields.Next()
        if field_found:
            gp.DeleteField_management(FileName, FieldName)
        gp.AddField_management(FileName, FieldName, Type, Precision, Scale, "", "", "NON_NULLABLE", "NON_REQUIRED", "")
        return FileName

    # percentiles list (10, 25, 50, 75, 90)
    def getPercentiles(list):
        PctList = []
        PctList.append(stats.scoreatpercentile(list, 10))
        PctList.append(stats.scoreatpercentile(list, 25))
        PctList.append(stats.scoreatpercentile(list, 50))
        PctList.append(stats.scoreatpercentile(list, 75))
        PctList.append(stats.scoreatpercentile(list, 90))
        return PctList

    def fetchLength(inFloat, outFloat):
        # calculates the fetch from top to bottom
        # read the header information
        finHeaderName = inFloat[:-3] + "hdr"
        fin = open(finHeaderName, 'r')
        header = fin.readlines()
        fin.close()
        # store header fields we need for later
        ncols = int(header[0].split()[1])
        nrows = int(header[1].split()[1])
        xllcorner = float(header[2].split()[1])
        yllcorner = float(header[3].split()[1])
        fgp.cellsize = float(header[4].split()[1])
        # apply shift since final output seems to be shifted a bit
        xllcorner = xllcorner
        yllcorner = yllcorner
        header[2] = "xllcorner     %s\n" % str(xllcorner)
        header[3] = "yllcorner     %s\n" % str(yllcorner)
        # copy header into new float header
        foutHeaderName = outFloat[:-3] + "hdr"
        fout = open(foutHeaderName, 'w')
        fout.writelines(header)
        fout.close()
        # open data files for processing
        fin = open(inFloat, 'rb')
        fout = open(outFloat, 'wb')
        fetch = array.array("f", [(-1 * fgp.cellsize) for i in range(ncols)])
        # walk down the DEM from the top row
        for row in xrange(nrows):
            # get the next (first) elevation row from the DEM 
            land = array.array("f")
            land.fromfile(fin, ncols)
            # calculate the fetch for this row
            for col in xrange(ncols):
                if land[col] > 0:
                    # found land, reset fetch length to zero
                    fetch[col] = 0
                else:
                    # found water, increment fetch length by cellsize
                    if fetch[col] >= 0:
                        # bounded fetch, positive fetch length
                        fetch[col] = fetch[col] + fgp.cellsize
                    else:
                        # unbounded fetch (so far), negative fetch length
                        fetch[col] = fetch[col] - fgp.cellsize
            # write the fetch for this row out to the new float binary
            fetch.write(fout)
        # close up the files        
        fin.close()
        fout.close()

    def calcSingle(inGrid, windDir, windDirInt, fetchpath):
        # calculate fetch along one wind direction
        windDir = (-1 * windDir) % 360.0
        input = inGrid
        output = fgp.tempGrid()
        fgp.deleteGrid(output)
        pivot = fgp.rotateGrid(input, output, windDir)
        # converting raster to float binary
        input = output
        output = fgp.tempFloat()
        fgp.deleteFloat(output)
        fgp.rasterToFloat(input, output)
        fgp.deleteGrid(input)
        # calculate the fetch length
        input = output
        output = fgp.tempFloat()
        fgp.deleteFloat(output)
        fetchLength(input, output)
        fgp.deleteFloat(input)
        # converting fetch binary to raster
        input = output
        output = fgp.tempGrid()
        fgp.deleteGrid(output)
        fgp.floatToRaster(input, output)
        fgp.deleteFloat(input)
        # rotating raster into north alignment (reverse the rotation performed above)
        input = output
        output = fgp.tempGrid()
        fgp.deleteGrid(output)
        angle = (-1 * windDir) % 360.0
        fgp.rotateGrid(input, output, angle, pivot)
        fgp.deleteGrid(input)
        # clipping final grid
        input = output
        output = fgp.tempGrid()
        clipGrid = inGrid
        fgp.deleteGrid(output)
        fgp.clipToGrid(input, output, clipGrid)
        fgp.deleteGrid(input)
        # setting fetch length = 0.0 to NODATA
        input = output
        output = fgp.tempGrid()
        fgp.deleteGrid(output)
        gp.SetNull_sa(input, input, output, "Value = 0")
        fgp.deleteGrid(input)
        # convert grid to integer for allocation process
        input = output
        output = fgp.tempGrid()
        fgp.deleteGrid(output)
        gp.Int_sa(input, output)
        fgp.deleteGrid(input)
        # allocate a few cells length buffer around results to make sure we intersect the shoreline
        input = output
        RasterName = "dir" + str(windDirInt).zfill(3)
        outRaster = os.path.join(fetchpath, RasterName)
        tempFinal = fgp.tempGrid()
        fgp.deleteGrid(tempFinal)
        distance = str(4.0 * fgp.cellsize)
        Output_distance_raster = ""
        Output_direction_raster = ""
        gp.EucAllocation_sa(input, tempFinal, distance, "", str(fgp.cellsize), "VALUE", Output_distance_raster, Output_direction_raster)
        fgp.deleteGrid(input)
        # copy the final temp file into the finished directory and rename
        tempMask = fgp.tempGrid()
        fgp.deleteGrid(tempMask)
        gp.Con_sa(inGrid, "1", tempMask, "", "Value = 0")
        tempClip = fgp.tempGrid()
        fgp.deleteGrid(tempClip)
        gp.ExtractByMask_sa(tempFinal, tempMask, tempClip)
        gp.SingleOutputMapAlgebra_sa("INT ( " + tempClip + " + 0.5)", outRaster, "")
        # clean up the remaining temp files
        fgp.deleteGrid(tempFinal)
        fgp.deleteGrid(tempMask)
        fgp.deleteGrid(tempClip)

    def expandExtent(inGrid):
        dsc = gp.Describe(inGrid)          
        extentList = dsc.Extent.split(" ")
        XMin1 = float(extentList[0])
        YMin1 = float(extentList[1])
        XMax1 = float(extentList[2])
        YMax1 = float(extentList[3])
        XDiff = XMax1 - XMin1
        YDiff = YMax1 - YMin1
        gridCenterX = (XMin1 + (XDiff / 2))
        gridCenterY = (YMin1 + (YDiff / 2))
        hypDiff = pow(((XDiff * XDiff) + (YDiff * YDiff)), 0.5)
        hypDiff = (hypDiff / 2)
        XMin2 = gridCenterX - hypDiff
        YMin2 = gridCenterY - hypDiff
        XMax2 = gridCenterX + hypDiff
        YMax2 = gridCenterY + hypDiff 
        extentString = str(XMin2) + " " + str(YMin2) + " " + str(XMax2) + " " + str(YMax2)
        gp.Extent = extentString

        
    #########################################################################################
    #########################################################################################

    try:
        gp.AddMessage("\nChecking inputs and preparing data...")
        # check geometry
        checkGeometry(landPoly, "Polygon", "Land Polygon")
        checkGeometry(landLine, "Polyline", "Land Polyline")
        checkGeometry(AOI, "Polygon", "Area of Interest (AOI)")
        if AOI:    
            checkGeometry(AOI, "Polygon", "Area of Interest (AOI)")
        if kelp:
            checkGeometry(kelp, "Polygon", "Kelp")
        if eelgrass:
            checkGeometry(eelgrass, "Polygon", "Eelgrass")
        if shorezone:
            checkGeometry(shorezone, "Polyline", "Shoreline Type")
        if comarg:
            checkGeometry(comarg, "Polygon", "Continental Shelf")
        if SeaLevRise:
            checkGeometry(SeaLevRise, "Polygon", "Feature Indicating Net Rise or Decrease")
    except:
        gp.AddError(msgCheckGeom)
        raise Exception

    try:
        # check the datum of certain inputs
        theinputs=[landPoly, landLine, AOI, projection, kelp, eelgrass, shorezone, comarg, SeaLevRise]
        for input in theinputs:
            if input:
                checkDatum(input)
    except:
        gp.AddError(msgCheckDatum)
        raise Exception

    if comarg:
        try:
            # check that AOI intersects the continental shelf
            gp.MakeFeatureLayer_management(AOI, aoi_lyr, "", "", "")
            gp.MakeFeatureLayer_management(comarg, comarg_lyr, "", "", "")
            SelectAOI = gp.SelectLayerByLocation(aoi_lyr, "INTERSECT", comarg_lyr, "", "NEW_SELECTION")
            if gp.GetCount(SelectAOI) > 0:
                pass
            else:
                gp.AddError("The input AOI boundary does not intersect the continental shelf.\nResize the AOI to overlap with relevant areas of the continental shelf.")
                raise Exception 
        except:
            gp.AddError(msgAOIcshelf)
            raise Exception

    try:
        # prepare the data
        gp.Clip_analysis(landLine, AOI, landLine_clip, "")
        if areaFilter:
            gp.Select_analysis(landLine_clip, coast_select, "\"area\" >= "+areaFilter)
        else:
            coast_select = landLine_clip
        gp.Project_management(coast_select, coast_select_prj, projection)
        coast_select_prj = AddField(coast_select_prj, "ID", "SHORT", "0", "")
        gp.CalculateField_management(coast_select_prj, "ID", 1, "VB")
        gp.FeatureToRaster_conversion(coast_select_prj, "ID", coast_rst, cellsize)
        gp.Clip_analysis(landPoly, AOI, landPoly_clip, "")
        gp.Project_management(landPoly_clip, coastPoly_prj, projection)
        coastPoly_prj = AddField(coastPoly_prj, "land", "SHORT", "0", "")
        gp.CalculateField_management(coastPoly_prj, "land", 2, "VB")
        gp.Project_management(AOI, aoi_prj, projection)
        AOI = AddField(aoi_prj, "land", "SHORT", "0", "")
        gp.CalculateField_management(aoi_prj, "land", 1, "VB")
        gp.FeatureToRaster_conversion(aoi_prj, "land", aoi_rst, cellsize)
        gp.FeatureToRaster_conversion(coastPoly_prj, "land", coastPoly_rst, cellsize)
        # set extent and cellsize
        gp.Extent = aoi_rst
        gp.CellSize = cellsize
        MergeExpr = "Merge("+coastPoly_rst+","+aoi_rst+")"
        gp.SingleOutputMapAlgebra_sa(MergeExpr, landsea)
        gp.Reclassify_sa(landsea, "VALUE", "1 0;2 1", landsea_rst, "DATA")
        gp.Reclassify_sa(landsea_rst, "VALUE", "1 NODATA;0 1", costsurf, "DATA")
        gp.Expand_sa(costsurf, costsurf_e, "1", "1")
        gp.ProjectRaster_management(globalPop, pop_prj, projection, "BILINEAR", cellsize, "", "", "")  
    except:
        gp.AddError(msgDataPrep)
        raise Exception

    # list for the 16 directions (used for fetch, wind and veg calculations)
    inp = [0, 22.5, 45, 67.5, 90, 112.5, 135, 157.5, 180, 202.5, 225, 247.5, 270, 292.5, 315, 337.5]

    if WindExp == "true":
        gp.AddMessage("\nDetermining wind exposure and fetch distances...")
    else:
        gp.AddMessage("\nCalculating fetch distances...")

    if WindExp == "true":
        try:
            # read in wind data
            WindData = open(Wind8minAvg,"r")
            line = WindData.readline() # read all data in as one line
            speed = [float(s) for s in line.split(",")] # split the list by comma delimiter
            del line
            line = WindData.readline() # read all data in as one line
            direction = [float(s) for s in line.split(",")] # split the list by comma delimiter
            del line

            # top 5%
            def sort_table(table, col=0):
                return sorted(table, key=operator.itemgetter(col))

            arrayDS = []
            for i in range(0,len(direction)):
                listDS = []
                listDS.append(direction[i])
                listDS.append(speed[i])
                listDStemp = list(listDS)
                arrayDS.append(listDStemp)
            sortDS = sort_table(arrayDS, 1)
            selectNum = int(.05*len(speed))

            Top5D = []
            Top5S = []
            for j in range(len(speed)-1,(len(speed)-1-selectNum),-1):
                Top5D.append(sortDS[j][0])
                Top5S.append(sortDS[j][1])

            binTop5W1 = []
            binTop5W2 = []
            binTop5W3 = []
            binTop5W4 = []
            binTop5W5 = []
            binTop5W6 = []
            binTop5W7 = []
            binTop5W8 = []
            binTop5W9 = []
            binTop5W10 = []
            binTop5W11 = []
            binTop5W12 = []
            binTop5W13 = []
            binTop5W14 = []
            binTop5W15 = []
            binTop5W16 = []

            for i in range(0,len(Top5D)):
                if Top5D[i] >= 0.0 and Top5D[i] < 22.5:
                    binTop5W1.append(Top5S[i])
                if Top5D[i] >= 22.5 and Top5D[i] < 45.0:
                    binTop5W2.append(Top5S[i])
                if Top5D[i] >= 45.0 and Top5D[i] < 67.5:
                    binTop5W3.append(Top5S[i])
                if Top5D[i] >= 67.5 and Top5D[i] < 90.0:
                    binTop5W4.append(Top5S[i])
                if Top5D[i] >= 90.0 and Top5D[i] < 112.5:
                    binTop5W5.append(Top5S[i])
                if Top5D[i] >= 112.5 and Top5D[i] < 135.0:
                    binTop5W6.append(Top5S[i])
                if Top5D[i] >= 135.0 and Top5D[i] < 157.5:
                    binTop5W7.append(Top5S[i])
                if Top5D[i] >= 157.5 and Top5D[i] < 180.0:
                    binTop5W8.append(Top5S[i])
                if Top5D[i] >= 180.0 and Top5D[i] < 202.5:
                    binTop5W9.append(Top5S[i])
                if Top5D[i] >= 202.5 and Top5D[i] < 225.0:
                    binTop5W10.append(Top5S[i])
                if Top5D[i] >= 225.0 and Top5D[i] < 247.5:
                    binTop5W11.append(Top5S[i])
                if Top5D[i] >= 247.5 and Top5D[i] < 270.0:
                    binTop5W12.append(Top5S[i])
                if Top5D[i] >= 270.0 and Top5D[i] < 292.5:
                    binTop5W13.append(Top5S[i])
                if Top5D[i] >= 292.5 and Top5D[i] < 315.0:
                    binTop5W14.append(Top5S[i])
                if Top5D[i] >= 315.0 and Top5D[i] < 337.5:
                    binTop5W15.append(Top5S[i])
                if Top5D[i] >= 337.5 and Top5D[i] < 360.0:
                    binTop5W16.append(Top5S[i])    

            MeanTop5WindList = numpy.zeros(16, dtype=numpy.float64)
            if len(binTop5W1) <> 0:
                MeanTop5WindList[3] = numpy.mean(binTop5W1)
            if len(binTop5W2) <> 0:
                MeanTop5WindList[2] = numpy.mean(binTop5W2)
            if len(binTop5W3) <> 0:
                MeanTop5WindList[1] = numpy.mean(binTop5W3)    
            if len(binTop5W4) <> 0:
                MeanTop5WindList[0] = numpy.mean(binTop5W4)
            if len(binTop5W5) <> 0:
                MeanTop5WindList[15] = numpy.mean(binTop5W5)  
            if len(binTop5W6) <> 0:
                MeanTop5WindList[14] = numpy.mean(binTop5W6)
            if len(binTop5W7) <> 0:
                MeanTop5WindList[13] = numpy.mean(binTop5W7)
            if len(binTop5W8) <> 0:
                MeanTop5WindList[12] = numpy.mean(binTop5W8)
            if len(binTop5W9) <> 0:
                MeanTop5WindList[11] = numpy.mean(binTop5W9)
            if len(binTop5W10) <> 0:
                MeanTop5WindList[10] = numpy.mean(binTop5W10)
            if len(binTop5W11) <> 0:
                MeanTop5WindList[9] = numpy.mean(binTop5W11)
            if len(binTop5W12) <> 0:
                MeanTop5WindList[8] = numpy.mean(binTop5W12)
            if len(binTop5W13) <> 0:
                MeanTop5WindList[7] = numpy.mean(binTop5W13)
            if len(binTop5W14) <> 0:
                MeanTop5WindList[6] = numpy.mean(binTop5W14)
            if len(binTop5W15) <> 0:
                MeanTop5WindList[5] = numpy.mean(binTop5W15)
            if len(binTop5W16) <> 0:
                MeanTop5WindList[4] = numpy.mean(binTop5W16)

            binDA1 = []
            binDA2 = []
            binDA3 = []
            binDA4 = []
            binDA5 = []
            binDA6 = []
            binDA7 = []
            binDA8 = []
            binDA9 = []
            binDA10 = []
            binDA11 = []
            binDA12 = []
            binDA13 = []
            binDA14 = []
            binDA15 = []
            binDA16 = []

            for i in range(0,len(direction)):
                if direction[i] >= 0.0 and direction[i] < 22.5:
                    binDA1.append(speed[i])
                elif direction[i] >= 22.5 and direction[i] < 45.0:
                    binDA2.append(speed[i])
                elif direction[i] >= 45.0 and direction[i] < 67.5:
                    binDA3.append(speed[i])
                elif direction[i] >= 67.5 and direction[i] < 90.0:
                    binDA4.append(speed[i])
                elif direction[i] >= 90.0 and direction[i] < 112.5:
                    binDA5.append(speed[i])
                elif direction[i] >= 112.5 and direction[i] < 135.0:
                    binDA6.append(speed[i])
                elif direction[i] >= 135.0 and direction[i] < 157.5:
                    binDA7.append(speed[i])
                elif direction[i] >= 157.5 and direction[i] < 180.0:
                    binDA8.append(speed[i])
                elif direction[i] >= 180.0 and direction[i] < 202.5:
                    binDA9.append(speed[i])
                elif direction[i] >= 202.5 and direction[i] < 225.0:
                    binDA10.append(speed[i])
                elif direction[i] >= 225.0 and direction[i] < 247.5:
                    binDA11.append(speed[i])
                elif direction[i] >= 247.5 and direction[i] < 270.0:
                    binDA12.append(speed[i])
                elif direction[i] >= 270.0 and direction[i] < 292.5:
                    binDA13.append(speed[i])
                elif direction[i] >= 292.5 and direction[i] < 315.0:
                    binDA14.append(speed[i])
                elif direction[i] >= 315.0 and direction[i] < 337.5:
                    binDA15.append(speed[i])
                elif direction[i] >= 337.5 and direction[i] < 360.0:
                    binDA16.append(speed[i])

            MaxWindList = []
            MaxWindList.append(max(binDA1))
            MaxWindList.append(max(binDA2))
            MaxWindList.append(max(binDA3))
            MaxWindList.append(max(binDA4))
            MaxWindList.append(max(binDA5))
            MaxWindList.append(max(binDA6))
            MaxWindList.append(max(binDA7))
            MaxWindList.append(max(binDA8))
            MaxWindList.append(max(binDA9))
            MaxWindList.append(max(binDA10))
            MaxWindList.append(max(binDA11))
            MaxWindList.append(max(binDA12))
            MaxWindList.append(max(binDA13))
            MaxWindList.append(max(binDA14))
            MaxWindList.append(max(binDA15))
            MaxWindList.append(max(binDA16))
            WindData.close()
        except:
            gp.AddError(msgWindCalc)
            raise Exception

    try:
        gp = Dispatch("esriGeoprocessing.GPDispatch.1")
        fgp = fetchGeoprocessor(gp)
        dirName = "fetch"
        fetchpath = os.path.join(interws, dirName)
        gp.CreateFolder_management(interws, dirName)
        expandExtent(landsea_rst)
        dirList = ["dir000", "dir022", "dir045", "dir067", "dir090", \
                   "dir112", "dir135", "dir157", "dir180", "dir202", \
                   "dir225", "dir247", "dir270", "dir292", "dir315", "dir337"]
        for IndWindDir in range(0,len(inp)):
            windDir = float(inp[IndWindDir])
            windDirInt = int(windDir)
            calcSingle(landsea_rst, windDir, windDirInt, fetchpath)

        for i in range(0,len(dirList)):
            gp.Reclassify_sa(fetchpath+"\\"+dirList[i], "Value", "-1000000 0 20000;0 250 0; 250 1000 625;1000 2000 1500;\
                                                                  2000 3000 2500;3000 4000 3500;4000 5000 4500;5000 6000 5500;\
                                                                  6000 7000 6500;7000 8000 7500;8000 9000 8500;9000 10000 9500;\
                                                                  10000 11000 10500;11000 12000 11500;12000 13000 12500;\
                                                                  13000 14000 13500;14000 15000 14500;15000 16000 15500;\
                                                                  16000 17000 16500;17000 18000 17500;18000 19000 18500;\
                                                                  19000 20000 19500;20000 10000000 20000", fetchpath+"\\"+dirList[i]+"_rc", "DATA")
            
            gp.Expand_sa(fetchpath+"\\"+dirList[i]+"_rc", fetchpath+"\\"+dirList[i]+"_e", "2", "0; \
                                                          625;1500;2500;3500;4500;5500;6500;7500;8500;9500;10500;\
                                                          11500;12500;13500;14500;15500;16500;17500;18500;19500;20000")
        del gp
    except:
        gp.AddError(msgFetchCalc)
        raise Exception

    #########################################################################################
    #########################################################################################

    # recreate geoprocessor
    gp = arcgisscripting.create()

    try:
        # read in index parameters from Excel
        xlApp = Dispatch("Excel.Application")
        xlApp.Visible = 0
        xlApp.DisplayAlerts=0
        xlBook1 = xlApp.Workbooks.Open(IndexParameters[:-(1+len(IndexParameters.split("\\")[-1]))])
        xlSheet1 = xlBook1.Worksheets("Indices")
        kelpDist = xlSheet1.Cells(2,2).Value
        eelgDist = xlSheet1.Cells(3,2).Value
        vegCellSize = xlSheet1.Cells(4,2).Value
        cd_maxDist = xlSheet1.Cells(8,2).Value
        fetchDist = xlSheet1.Cells(12,2).Value

        idList = []
        rankList = []
        row = 2
        col = 5
        counter = 2
        bottom = row
        while xlSheet1.Cells(bottom, col).Value not in [None, '']:
            bottom += 1
        while counter <= bottom:
            idList.append(xlSheet1.Cells(counter,5).Value)
            rankList.append(xlSheet1.Cells(counter,6).Value)
            counter = counter + 1
        xlApp.ActiveWorkbook.Close(SaveChanges=0)
        xlApp.Quit()
        del xlApp
    except:
        gp.AddError(msgExpIndexParameters)
        raise Exception

    # reset extent to land and sea raster
    gp.Extent = landsea_rst

    if Biogenic == "true":
        try:
            # search for biogenic influence on coastline
            gp.AddMessage("\nIncorporating natural habitat...")
            vegName = "veg"
            vegpath = os.path.join(interws, vegName)
            gp.CreateFolder_management(interws, vegName)

            if kelp:    
                gp.Project_management(kelp, kelp_prj, projection)
                kelp_prj = AddField(kelp_prj, "ID", "SHORT", "0", "0")
                gp.CalculateField_management(kelp_prj, "ID", 1, "VB")
                gp.FeatureToRaster_conversion(kelp_prj, "ID", kelp_rst, vegCellSize)
            if eelgrass:
                gp.Project_management(eelgrass, eelg_prj, projection)
                eelg_prj = AddField(eelg_prj, "ID", "SHORT", "0", "0")
                gp.CalculateField_management(eelg_prj, "ID", 1, "VB")
                gp.FeatureToRaster_conversion(eelg_prj, "ID", eelg_rst, vegCellSize)
                
            if kelp:  
                kelpWedgeExpr = "Circle "+str(kelpDist)+" MAP"
                gp.FocalStatistics_sa(kelp_rst, vegpath+"\\kelpshd_360", kelpWedgeExpr, "MEAN", "DATA")
            if eelgrass:         
                eelgWedgeExpr = "Circle "+str(eelgDist)+" MAP"
                gp.FocalStatistics_sa(eelg_rst, vegpath+"\\eelgshd_360", eelgWedgeExpr, "MEAN", "DATA")

            MergeExpr = ""
            if kelp and eelgrass:            
                MergeExpr = "Merge("+vegpath+"\\kelpshd_360,"+vegpath+"\\eelgshd_360)"
            if kelp and not eelgrass:
                MergeExpr = vegpath+"\\kelpshd_360"
            if eelgrass and not kelp:
                MergeExpr = vegpath+"\\eelgshd_360"
                
            gp.SingleOutputMapAlgebra_sa(MergeExpr, veg_merge)
            gp.Reclassify_sa(veg_merge, "VALUE", "1 5 4;NODATA 5", veg_rc, "DATA")
        except:
            gp.AddError(msgBiogenicHab)
            raise Exception



    try:
        # prep geomorphology input for coastline output
        gp.AddMessage("\nIncorporating geomorphology...")
        gp.Project_management(shorezone, sz_prj, projection)
        gp.FeatureToRaster_conversion(sz_prj, "ID", sz_rst, cellsize)
        ExpandExpr = "0"
        for i in range(1,bottom-1):
            ExpandExpr = ExpandExpr+";"+str(i)
        gp.Expand_sa(sz_rst, sz_e, "2", ExpandExpr)
        gp.Reclassify_sa(sz_e, "VALUE", "1 1;NODATA 0", sz_rc, "DATA")
    except:
        gp.AddError(msgGeomorph)
        raise Exception
        
    if DistShelf == "true":
        try:
            # calculate distance to shelf
            gp.AddMessage("\nCalculating distance to continental shelf for surge potential...")
            gp.Project_management(comarg, comarg_prj, projection)
            comarg_prj = AddField(comarg_prj, "ID", "SHORT", "0", "0")
            gp.CalculateField_management(comarg_prj, "ID", 1, "VB")
            gp.FeatureToRaster_conversion(comarg_prj, "ID", comarg_rst, cellsize)
            gp.CostDistance_sa(comarg_rst, costsurf_e, costdist, str(cd_maxDist),  "")
            gp.MosaicToNewRaster_management(costdist+";"+aoi_rst, interws, "costdist_rc", projection, "32_BIT_FLOAT", "", "1", "MAXIMUM", "FIRST")
        except:
            gp.AddError(msgDistShelf)
            raise Exception

    if SeaLevChange == "true":
        try:
        # sea level rise
            gp.AddMessage("\nAssigning areas prone to sea level rise and decline...")
            gp.Project_management(SeaLevRise, slr_prj, projection)
            gp.FeatureToRaster_conversion(slr_prj, "RANK", slr_rst, cellsize)
            gp.Reclassify_sa(slr_rst, "VALUE", "1 1;NODATA 0", slr_rc, "DATA")
        except:
            gp.AddError(msgSeaLevRise)
            raise Exception

    ###############################################################################################################################################
    ###############################################################################################################################################

    try:
        # combine various index rasters
        gp.AddMessage("\nCombining results and generating outputs...")    
        gp.Mask = coast_rst
        gp.snapRaster = coast_rst

        CmbExpr = fetchpath+"\\"+dirList[0]+"_e"
        for i in range(1,len(dirList)):
            CmbExpr = CmbExpr+";"+fetchpath+"\\"+dirList[i]+"_e"
        CmbExpr = CmbExpr+";"+sz_rc 
        if Biogenic == "true":
            CmbExpr = CmbExpr+";"+veg_rc
        if DistShelf == "true":
            CmbExpr = CmbExpr+";"+costdist_rc
        if SeaLevChange == "true":
            CmbExpr = CmbExpr+";"+slr_rc

        gp.Combine_sa(CmbExpr, exp_index)
        exp_index = AddField(exp_index, "FFILT", "SHORT", "", "")
    except:
        gp.AddError(msgCombineIndex)
        raise Exception

    try:
        gp.AddMessage("...extracting coastal population")
        # population classification
        gp.ExtractByMask_sa(pop_prj, exp_index, coast_pop)
        gp.Reclassify_sa(coast_pop, "VALUE", "0 NODATA", coast_pop_rc, "DATA")
        gp.RasterToPoint_conversion(coast_pop_rc, coast_pop_Pts)

        costPopList = []
        cur = gp.UpdateCursor(coast_pop_Pts)
        row = cur.Next()
        while row:
            if row.GRID_CODE > 0:
                costPopList.append(row.GRID_CODE)
            cur.UpdateRow(row)
            row = cur.next()
        del row
        del cur

        # creates a list for breaks (10, 25, 50, 75, 90)
        coastPopList = getPercentiles(costPopList)
        coast_pop_Pts = AddField(coast_pop_Pts, "POP_BREAK", "SHORT", "", "")
        coast_pop_Pts = AddField(coast_pop_Pts, "POP_RANGE", "TEXT", "30", "")
        coast_pop_Pts = AddField(coast_pop_Pts, "VAL_BREAKS", "TEXT", "50", "")

        cur = gp.UpdateCursor(coast_pop_Pts, "", "", "POP_BREAK; POP_RANGE; VAL_BREAKS; GRID_CODE")
        row = cur.Next()
        while row:
            if row.GRID_CODE < coastPopList[1]:
                row.SetValue("POP_BREAK", 1)
                row.SetValue("POP_RANGE", "< 25th Pctile")
                row.SetValue("VAL_BREAKS", "Population < "+str(int(coastPopList[1]))+" People")
            if row.GRID_CODE >= coastPopList[1] and row.GRID_CODE <= coastPopList[2]:
                row.SetValue("POP_BREAK", 2)
                row.SetValue("POP_RANGE", "25-50th Pctile")
                row.SetValue("VAL_BREAKS", str(int(coastPopList[1]))+" <= Population < "+str(int(coastPopList[2]))+" People")
            if row.GRID_CODE >= coastPopList[2] and row.GRID_CODE <= coastPopList[3]:
                row.SetValue("POP_BREAK", 3)
                row.SetValue("POP_RANGE", "50-75th Pctile")
                row.SetValue("VAL_BREAKS", str(int(coastPopList[2]))+" <= Population < "+str(int(coastPopList[3]))+" People")
            if row.GRID_CODE > coastPopList[3]:
                row.SetValue("POP_BREAK", 4)
                row.SetValue("POP_RANGE", "> 75th Pctile")
                row.SetValue("VAL_BREAKS", "Population >= "+str(int(coastPopList[3]))+" People")
            cur.UpdateRow(row)
            row = cur.next()
        del row
        del cur
    except:
        gp.AddError(msgPopulationCalcs)
        raise Exception

    try:
        gp.AddMessage("...computing coastal exposure index (EI)") 
        # add fields for different indices
        exp_index = AddField(exp_index, "GEOMORPH", "SHORT", "", "")

        if WindExp == "true":    
            exp_index = AddField(exp_index, "REI_T5", "FLOAT", "", "")
            exp_index = AddField(exp_index, "HS", "FLOAT", "", "")
            exp_index = AddField(exp_index, "TP", "FLOAT", "", "")
            exp_index = AddField(exp_index, "WP", "FLOAT", "", "")

        # run through rows and perform calculations
        cur = gp.UpdateCursor(exp_index)
        row = cur.Next()
        while row:
            CellFetchList = []
            CellFetchList.append(row.DIR000_E)
            CellFetchList.append(row.DIR022_E)
            CellFetchList.append(row.DIR045_E)
            CellFetchList.append(row.DIR067_E)
            CellFetchList.append(row.DIR090_E)
            CellFetchList.append(row.DIR112_E)
            CellFetchList.append(row.DIR135_E)
            CellFetchList.append(row.DIR157_E)
            CellFetchList.append(row.DIR180_E)
            CellFetchList.append(row.DIR202_E)
            CellFetchList.append(row.DIR225_E)
            CellFetchList.append(row.DIR247_E)
            CellFetchList.append(row.DIR270_E)
            CellFetchList.append(row.DIR292_E)
            CellFetchList.append(row.DIR315_E)
            CellFetchList.append(row.DIR337_E)

            ZeroCount = CellFetchList.count(0)
            count = 0
            if row.DIR000_E >= fetchDist:
                count = count + 1
            if row.DIR022_E >= fetchDist:
                count = count + 1
            if row.DIR045_E >= fetchDist:
                count = count + 1
            if row.DIR067_E >= fetchDist:
                count = count + 1
            if row.DIR090_E >= fetchDist:
                count = count + 1
            if row.DIR112_E >= fetchDist:
                count = count + 1
            if row.DIR135_E >= fetchDist:
                count = count + 1
            if row.DIR157_E >= fetchDist:
                count = count + 1
            if row.DIR180_E >= fetchDist:
                count = count + 1
            if row.DIR202_E >= fetchDist:
                count = count + 1
            if row.DIR225_E >= fetchDist:
                count = count + 1
            if row.DIR247_E >= fetchDist:
                count = count + 1
            if row.DIR270_E >= fetchDist:
                count = count + 1
            if row.DIR292_E >= fetchDist:
                count = count + 1
            if row.DIR315_E >= fetchDist:
                count = count + 1
            if row.DIR337_E >= fetchDist:
                count = count + 1
            if count == 0 or count == 1:
                row.FFILT = 0
            else:
                row.FFILT = 1

            if WindExp == "true":
                # wave height and period calcs
                HList = numpy.zeros(16, dtype=numpy.float64)
                TList = numpy.zeros(16, dtype=numpy.float64)

                for k in range(0,16):
                    HList[k] = ((numpy.tanh((0.000414*((9.81*CellFetchList[k])/(MaxWindList[k]**2))**0.79)))**0.572)*((0.24*(MaxWindList[k]**2))/9.81)
                    TList[k] = ((numpy.tanh((0.000000277*((9.81*CellFetchList[k])/(MaxWindList[k]**2))**1.45)))**0.187)*((7.69*MaxWindList[k])/9.81)
                MeanH = numpy.mean(HList)
                MeanT = numpy.mean(TList) 

                # wave power calcs
                WavePowerList = []
                for n in range(0,len(HList)):
                    WavePowerList.append((HList[n]**2)*TList[n]*0.5)
                if ZeroCount == 16:
                    MeanWavePower = 0.0
                else:
                    MeanWavePower = (numpy.sum(WavePowerList)/(16-ZeroCount))

                # REI (average top 5% wind speed)
                REI_Top5 = 0.0
                LengthTop5 = float(len(Top5S))
                LengthbinTop5WList = []
                LengthbinTop5WList.append(float(len(binTop5W1)))
                LengthbinTop5WList.append(float(len(binTop5W2)))
                LengthbinTop5WList.append(float(len(binTop5W3)))
                LengthbinTop5WList.append(float(len(binTop5W4)))
                LengthbinTop5WList.append(float(len(binTop5W5)))
                LengthbinTop5WList.append(float(len(binTop5W6)))
                LengthbinTop5WList.append(float(len(binTop5W7)))
                LengthbinTop5WList.append(float(len(binTop5W8)))
                LengthbinTop5WList.append(float(len(binTop5W9)))
                LengthbinTop5WList.append(float(len(binTop5W10)))
                LengthbinTop5WList.append(float(len(binTop5W11)))
                LengthbinTop5WList.append(float(len(binTop5W12)))
                LengthbinTop5WList.append(float(len(binTop5W13)))
                LengthbinTop5WList.append(float(len(binTop5W14)))
                LengthbinTop5WList.append(float(len(binTop5W15)))
                LengthbinTop5WList.append(float(len(binTop5W16)))

                for j in range(0,16):
                    P = float(LengthbinTop5WList[j]/LengthTop5)
                    REI_Top5 = REI_Top5 + float(MeanTop5WindList[j] * P * CellFetchList[j])

                row.REI_T5 = REI_Top5
                row.HS = MeanH
                row.TP = MeanT
                row.WP = MeanWavePower


            if row.SZ_RC == 0:
                row.GEOMORPH = 0
            else:
                IDNum = row.SZ_RC
                indexNum = idList.index(IDNum)
                row.GEOMORPH = rankList[indexNum]

            cur.UpdateRow(row)
            row = cur.next()
        del row
        del cur

        # creates a list for breaks (10, 25, 50, 75, 90)
        if WindExp == "true":
            WindExpList = []
            WaveExpList = []
            
        cur = gp.UpdateCursor(exp_index)
        row = cur.Next()
        while row:
            CellCount = int(row.COUNT)
            if WindExp == "true":
                for i in range(CellCount):
                    WindExpList.append(row.REI_T5)
                    WaveExpList.append(row.WP)

            if Biogenic == "true":
                if row.GEOMORPH == 1:
                    row.VEG_RC = 0
                    
            cur.UpdateRow(row)
            row = cur.next()
        del row
        del cur

        if WindExp == "true":
            WindExpPctList = getPercentiles(WindExpList)
            WaveExpPctList = getPercentiles(WaveExpList)
            exp_index = AddField(exp_index, "WINDEXP", "SHORT", "", "")
            exp_index = AddField(exp_index, "WAVEEXP", "SHORT", "", "")

        if DistShelf == "true":
            SurgePotList = []

        cur = gp.UpdateCursor(exp_index)
        row = cur.Next()
        while row:
            CellCount = int(row.COUNT)
            if WindExp == "true":
                if row.REI_T5 < WindExpPctList[0]:
                    row.WINDEXP = 1
                if row.REI_T5 >= WindExpPctList[0] and row.REI_T5 < WindExpPctList[1]:
                    row.WINDEXP = 2
                if row.REI_T5 >= WindExpPctList[1] and row.REI_T5 <= WindExpPctList[3]:
                    row.WINDEXP = 3
                if row.REI_T5 >= WindExpPctList[3] and row.REI_T5 <= WindExpPctList[4]:
                    row.WINDEXP = 4
                if row.REI_T5 > WindExpPctList[4]:
                    row.WINDEXP = 5

                if row.WP < WaveExpPctList[0]:
                    row.WAVEEXP = 1
                if row.WP >= WaveExpPctList[0] and row.WP < WaveExpPctList[1]:
                    row.WAVEEXP = 2
                if row.WP >= WaveExpPctList[1] and row.WP <= WaveExpPctList[3]:
                    row.WAVEEXP = 3
                if row.WP >= WaveExpPctList[3] and row.WP <= WaveExpPctList[4]:
                    row.WAVEEXP = 4
                if row.WP > WaveExpPctList[4]:
                    row.WAVEEXP = 5

            if DistShelf == "true":
                if row.COSTDIST_RC > 1:
                    for i in range(CellCount):
                        SurgePotList.append(row.COSTDIST_RC)

            cur.UpdateRow(row)
            row = cur.next()
        del row
        del cur

        if DistShelf == "true":
            SurgePotPctList = getPercentiles(SurgePotList)
            exp_index = AddField(exp_index, "SURGEPOT", "SHORT", "", "")

        # add final fields
        exp_index = AddField(exp_index, "BIOPHYS", "FLOAT", "", "")
        exp_index = AddField(exp_index, "EI", "FLOAT", "", "")

        # check fields for existance of various indices
        F_GEOMORPH = "false"
        F_WINDEXP = "false"
        F_WAVEEXP = "false"
        F_SURGEPOT = "false"
        F_VEG_RC = "false"
        F_SLR_RC = "false"

        fieldList = gp.ListFields (exp_index, "*", "All")
        field = fieldList.Next()
        while field <> None:
            if field.Name == "GEOMORPH":
                F_GEOMORPH = "true"
            if field.Name == "VEG_RC":
                F_VEG_RC = "true"        
            if field.Name == "WAVEEXP":
                F_WAVEEXP = "true"
            if field.Name == "SURGEPOT":
                F_SURGEPOT = "true"
            if field.Name == "SLR_RC":
                F_SLR_RC = "true"
            field = fieldList.Next()
        del fieldList
        del field

        # calculate exposure index (EI)
        cur = gp.UpdateCursor(exp_index)
        row = cur.Next()
        while row:
            if DistShelf == "true":
                if row.COSTDIST_RC == 1:
                    row.SURGEPOT = 1
                if row.COSTDIST_RC > 1 and row.COSTDIST_RC < SurgePotPctList[1]:
                    row.SURGEPOT = 2
                if row.COSTDIST_RC >= SurgePotPctList[1] and row.COSTDIST_RC <= SurgePotPctList[3]:
                    row.SURGEPOT = 3
                if row.COSTDIST_RC >= SurgePotPctList[3] and row.COSTDIST_RC <= SurgePotPctList[4]:
                    row.SURGEPOT = 4
                if row.COSTDIST_RC > SurgePotPctList[4]:
                    row.SURGEPOT = 5

            ## EXPOSURE INDEX (EI) ##
            BioPhysExpr = 0.0
            BioPhysCount = 0
            EIExpr = 1.0
            EICount = 0
            
            # geomorphology for phys
            if row.GEOMORPH == 1:
                F_VEG_RC == "false"
                BioPhysExpr = BioPhysExpr+row.GEOMORPH
                BioPhysCount += 1

            # natural habitat for phys    
            if row.GEOMORPH > 1:
                if F_VEG_RC == "true" and row.VEG_RC > 0:
                    BioPhysExpr = BioPhysExpr+(row.GEOMORPH*0.75)
                    BioPhysExpr = BioPhysExpr+(row.VEG_RC*0.25)
                    BioPhysCount += 2
                else:
                    BioPhysExpr = BioPhysExpr+row.GEOMORPH
                    BioPhysCount += 1

            if row.GEOMORPH == 0:
                row.BIOPHYS = -1
            else:
                row.BIOPHYS = (BioPhysExpr/BioPhysCount)
                EIExpr = EIExpr*(BioPhysExpr/BioPhysCount)
                EICount += 1

            # add all other indices to EI
            if F_SLR_RC == "true":
                if row.SLR_RC > 0:
                    EIExpr = EIExpr*row.SLR_RC
                    EICount += 1
            
            if F_WAVEEXP == "true":
                EIExpr = EIExpr*row.WAVEEXP
                EICount += 1

            if F_SURGEPOT == "true":
                EIExpr = EIExpr*row.SURGEPOT
                EICount += 1

            # calculate EI
            if row.GEOMORPH == 0:
                row.EI = -1
            else:
                row.EI = (((EIExpr)**0.5)/EICount)

            cur.UpdateRow(row)
            row = cur.next()
        del row
        del cur

        # delete fetch fields from final output
        gp.DeleteField_management(exp_index, "DIR000_E;DIR022_E;DIR045_E;DIR067_E;DIR090_E;DIR112_E;DIR135_E;DIR157_E;DIR180_E;DIR202_E;DIR225_E;DIR247_E;DIR270_E;DIR292_E;DIR315_E;DIR337_E")
        # create output with "EI" as only "value"
        gp.Lookup_sa(exp_index, "EI", coast_vuln)
        
    except:
        gp.AddError(msgExposureIndex)
        raise Exception

    ###############################################################################################################################################
    ###############################################################################################################################################

    # create parameter file
    parameters.append("Script location: "+os.path.dirname(sys.argv[0])+"\\"+os.path.basename(sys.argv[0]))
    parafile = open(gp.workspace+"\\Output\\parameters_"+now.strftime("%Y-%m-%d-%H-%M")+".txt","w") 
    parafile.writelines("COASTAL PROTECTION MODEL PARAMETERS\n")
    parafile.writelines("___________________________________\n\n")
         
    for para in parameters:
        parafile.writelines(para+"\n")
        parafile.writelines("\n")
    parafile.close()

    # delete superfluous intermediate data
    del1 = [landLine_clip, coast_select, coast_select_prj, coast_rst, landPoly_clip, coastPoly_rst, aoi_prj, aoi_rst, aoi_lyr, comarg_lyr, landsea]
    del2 = [costsurf, costsurf_e, pop_prj, coast_pop_rc, veg_merge, kelp_prj, kelp_rst, eelg_prj, eelg_rst, sz_prj, sz_rst, sz_e, comarg_prj, comarg_rst, costdist, costdist_rc, slr_prj, slr_rst]
    tempdata = ["temp003.prj", "temp023.prj", "temp043.prj", "temp063.prj", "temp083.prj", "temp103.prj", "temp123.prj", "temp143.prj", "temp163.prj", "temp183.prj", "temp203.prj", "temp223.prj", "temp243.prj", "temp263.prj", "temp283.prj", "temp303.prj"]
    deletelist = del1 + del2 + tempdata
    for data in deletelist:
        if gp.exists(data):
            gp.delete_management(data)
    gp.AddMessage("")
    del gp
    
except Exception, ErrorDesc:
    gp.AddMessage(gp.GetMessages())