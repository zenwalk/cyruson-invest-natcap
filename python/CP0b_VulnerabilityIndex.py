# Marine InVEST: Coastal Vulnerability Index
# Authors: Gregg Verutes, Greg Guannel, Jeremy Davies
# Coded for ArcGIS 9.3 and 10
# 07/20/11

import sys, string, os, datetime, array, time, datetime, shlex
from math import *
import arcgisscripting
import fpformat, operator

# create the geoprocessor object
gp = arcgisscripting.create()

# set output handling
gp.OverwriteOutput = 1
# check out extensions
gp.CheckOutExtension("spatial")
gp.CheckOutExtension("management")
gp.CheckOutExtension("analysis")
gp.CheckOutExtension("conversion")

# error messages
msgArguments = "\nProblem with arguments."
msgCheckGeom = "\nError checking the geometry of inputs."
msgCheckDatum = "\nError checking the datum of inputs."
msgCheckProjection = "\nError checking the projection of inputs."
msgAOIintersect = "\nError checking that the AOI input intersects the WW3 and continental shelf input data."
msgFetchThreshDist = "\nError reading fetch threshold distance from a text file."
msgWindWaveExposure = "\nError reading in wind and wave exposure data."
msgNatHabLayersTable = "\nError reading in natural habitat layers table."
msgBiogenicHab = "\nError incorporating biogenic habitat."
msgGeomorph = "\nError incorporating geomorphology."
msgDistShelf = "\nError calculating distance to shelf."
msgCoastalRelief = "\nError calculating coastal relief."
msgSeaLevRise = "\nError assigning input for expected sea level rise."
msgCostAlloc = "\nError allocating WW3 model data to coastline."
msgRankingWWS = "\nError ranking wind/wave exposure and surge potential."
msgCombineIndex = "\nError combining results for exposure index."
msgPopulationCalcs = "\nError extracting coastal population."
msgExposureIndex = "\nError calculating coastal exposure index."
msgNumPyNo = "NumPy extension is required to run the Coastal Vulnerability Model.  Please consult the Marine InVEST FAQ for instructions on how to install."
msgSciPyNo = "SciPy extension is required to run the Coastal Vulnerability Model.  Please consult the Marine InVEST FAQ for instructions on how to install."
msgWin32ComNo = "PythonWin extension is required to run the Coastal Vulnerability Model.  Please consult the Marine InVEST FAQ for instructions on how to install."

# import modules
try:
    import numpy
except:
    gp.AddError(msgNumPyNo)
    raise Exception

try:
    from scipy import stats
except:
    gp.AddError(msgSciPyNo)
    raise Exception
    
try:
    from win32com.client import Dispatch
except:
    gp.AddError(msgWin32ComNo)
    raise Exception

try:
    try:
        # get parameters
        parameters = []
        now = datetime.datetime.now()
        parameters.append("Date and Time: "+ now.strftime("%Y-%m-%d %H:%M"))
        gp.workspace = gp.GetParameterAsText(0)
        parameters.append("Workspace: "+ gp.workspace)
        gp.scratchWorkspace = gp.GetParameterAsText(0)
        parameters.append("Scratch Workspace: "+ gp.scratchWorkspace)
        FetchCalcWS = gp.GetParameterAsText(1)
        parameters.append("Fetch Calculator Tool Run Workspace: "+ FetchCalcWS)
        globalPop = gp.GetParameterAsText(2)
        parameters.append("Global Population Raster: "+ globalPop)      
        WW3_Pts = gp.GetParameterAsText(3)
        parameters.append("WIND-WAVE EXPOSURE - Wave Watch 3 Model Data: "+ WW3_Pts)
        DEM = gp.GetParameterAsText(4)
        parameters.append("RELIEF - Digital Elevation Model (DEM): "+ DEM)
        HabDirectory = gp.GetParameterAsText(5)
        parameters.append("NATURAL HABITAT - Directory with Layers: "+ HabDirectory)
        HabLayersTable = gp.GetParameterAsText(6)
        parameters.append("NATURAL HABITAT - Layers Table: "+ HabLayersTable)  
        geomorphology = gp.GetParameterAsText(7)
        parameters.append("GEOMORPHOLOGY - Shoreline Type: "+ geomorphology)
        comarg = gp.GetParameterAsText(8)
        parameters.append("SURGE POTENTIAL - Continental Margin: "+ comarg)
        SeaLevRise = gp.GetParameterAsText(9)
        parameters.append("SEA LEVEL RISE: Zones Indicating Net Rise or Decrease: "+ SeaLevRise)

    except:
        raise Exception, msgArguments + gp.GetMessages(2)
        
    # check and create folders
    try:
        thefolders=["intermediate", "Output"]
        for folder in thefolders:
            if not gp.exists(gp.workspace + folder):
                gp.CreateFolder_management(gp.workspace, folder)
    except:
        raise Exception, "Error creating folders"

    # intermediate and output directories
    outputws = gp.workspace + os.sep + "Output" + os.sep
    interws = gp.workspace + os.sep + "intermediate" + os.sep

    # fetch calculator run variables
    aoi_prj = FetchCalcWS + os.sep + "intermediate" + os.sep + "aoi_prj.shp"
    aoi_rst = FetchCalcWS + os.sep + "intermediate" + os.sep + "aoi_rst"
    costsurf_e = FetchCalcWS + os.sep + "intermediate" + os.sep + "costsurf_e"
    coast_rst = FetchCalcWS + os.sep + "intermediate" + os.sep + "coast_rst"
    landsea_rst = FetchCalcWS + os.sep + "intermediate" + os.sep + "landsea_rst"
    FetchFolder = FetchCalcWS + os.sep + "intermediate" + os.sep + "fetch" + os.sep
    fetch_cmb = FetchCalcWS + os.sep + "Output" + os.sep + "fetch_cmb"
    coastPoly_prj = FetchCalcWS + os.sep + "Output" + os.sep + "coastPoly_prj.shp"
    fetch_threshDist = FetchCalcWS + os.sep + "Output" + os.sep + "fetch_threshDist.txt"

    # prep variables
    WW3_Pts_lyr = interws + "WW3_Pts_lyr.lyr" 
    aoi_lyr = interws + "aoi_lyr.lyr"
    comarg_lyr = interws + "comarg_lyr.lyr"
    pop_prj = interws + "pop_prj"
    coast_pop_rc = interws + "coast_pop_rc"

    # exposure index variables
    fetch_cmb1 = interws + "fetch_cmb1"
    fetch_cmb2 = interws + "fetch_cmb2"
    wind_rank = interws + "wind_rank"
    wave_rank = interws + "wave_rank"
    surge_rank = interws + "surge_rank"
    ffilt = interws + "ffilt"
    ffilt_Pts = interws + "ffilt_Pts.shp"
    ffilt_Pts_select = interws + "ffilt_Pts_select.shp"
    ffilt_Pts_cd = interws + "ffilt_Pts_cd.shp"
    costd_alloc = interws + "costd_alloc"
    hab_merge = interws + "hab_merge"
    hab_nodata = interws + "hab_nodata"
    hab_rank = interws + "hab_rank"
    sz_rst = interws + "sz_rst"
    sz_e = interws + "sz_e"
    sz_rc = interws + "sz_rc"
    comarg_prj = interws + "comarg_prj.shp"
    comarg_rst = interws + "comarg_rst"
    costdist = interws + "costdist"
    costdist_rc = interws + "costdist_rc"
    dem_land = interws + "dem_land"
    relief_fs = interws + "relief_fs"
    relief_int = interws + "relief_int"
    relief_rc = interws + "relief_rc"
    slr_rst = interws + "slr_rst" 
    slr_rank = interws + "slr_rank"
    costa_ww3 = interws + "costa_ww3"
    WW3_Pts_clip = interws + "WW3_Pts_clip.shp"
    WW3_Pts_prj = interws + "WW3_Pts_prj.shp"

    # output variables
    coastPoly_prjCopy = outputws + "coastPoly_prj.shp" 
    coast_pop = outputws + "coast_pop"
    coast_pop_Pts = outputws + "coast_pop_Pts.shp"
    exp_index = outputws + "exp_index"
    eros_index = outputws + "eros_index"
    inund_index = outputws + "inund_index"
    vuln_index = outputws + "vuln_index"


    ##############################################
    ###### COMMON FUNCTION AND CHECK INPUTS ######
    ##############################################

    def checkGeometry(thedata, Type, Message):
        if gp.Describe(thedata).ShapeType <> Type:
            raise Exception, "\nInvalid input: "+thedata+"\n"+Message+" must be of geometry type "+Type+"."

    def checkDatum(thedata):
        desc = gp.describe(thedata)
        SR = desc.SpatialReference
        if SR.Type == "Geographic":
            strDatum = SR.DatumName         
        else:
            gp.OutputCoordinateSystem = SR
            strSR = str(gp.OutputCoordinateSystem)
            gp.OutputCoordinateSystem = ""
            n1 = strSR.find("DATUM[\'")
            n2 = strSR.find("\'",n1+7)
            strDatum = strSR[n1+7:n2]
        if strDatum == "D_WGS_1984":
            pass
        else:
            gp.AddError(thedata+" is not a valid input.\nThe model requires an AOI input with the \"WGS84\" datum.\nPlease review InVEST FAQ guide on how to reproject datasets.")
            raise Exception

    def ckProjection(data):
        dataDesc = gp.describe(data)
        spatreflc = dataDesc.SpatialReference
        if spatreflc.Type <> 'Projected':
            gp.AddError(data +" does not appear to be projected.  It is assumed to be in meters.")
            raise Exception
        if spatreflc.LinearUnitName <> 'Meter':
            gp.AddError("This model assumes that "+data+" is projected in meters for area calculations.  You may get erroneous results.")
            raise Exception

    def grabProjection(data):
        dataDesc = gp.describe(data)
        sr = dataDesc.SpatialReference
        gp.OutputCoordinateSystem = sr
        strSR = str(gp.OutputCoordinateSystem)
        return strSR

    def AddField(FileName, FieldName, Type, Precision, Scale):
        fields = gp.ListFields(FileName, FieldName)
        field_found = fields.Next()
        if field_found:
            gp.DeleteField_management(FileName, FieldName)
        gp.AddField_management(FileName, FieldName, Type, Precision, Scale, "", "", "NON_NULLABLE", "NON_REQUIRED", "")
        return FileName

    def checkField(FileName, FieldName):
        fields = gp.ListFields(FileName, FieldName)
        field_found = fields.Next()
        if field_found:
            pass
        else:
            gp.AddError("The geomorphology input must contain a field called 'RANK' with integer values ranging from 1 to 5.")
            raise Exception

    def getCellSize(thedata):
         desc=gp.Describe(thedata)
         CellWidth = desc.MeanCellWidth
         CellHeight = desc.MeanCellHeight
         return int((CellHeight+CellWidth)/2.0)
        
    def checkInteger(thedata):
        if thedata.find("0") == -1 and thedata.find("1") == -1 and thedata.find("2") == -1 and thedata.find("3") == -1 and thedata.find("4") == -1 and thedata.find("5") == -1 and thedata.find("6") == -1 and thedata.find("7") == -1 and thedata.find("8") == -1 and thedata.find("9") == -1:
            gp.AddError(thedata +" must contain an underscore followed by an integer ID at the end of it's name (e.g. filename_1.shp). This is necessary to properly link it with the input table.")
            raise Exception

    # percentiles list (10, 25, 50, 75, 90)
    def getPercentiles(list):
        PctList = []
        PctList.append(stats.scoreatpercentile(list, 10))
        PctList.append(stats.scoreatpercentile(list, 25))
        PctList.append(stats.scoreatpercentile(list, 50))
        PctList.append(stats.scoreatpercentile(list, 75))
        PctList.append(stats.scoreatpercentile(list, 90))
        return PctList
            
    try:
        gp.AddMessage("\nPreparing and checking inputs...")
        # check inputs
        if HabDirectory and not HabLayersTable:
            gp.AddError("\nCannot incorporate natural habitat without an associated layers table input.")
            raise Exception
        if geomorphology:
            checkGeometry(geomorphology, "Polyline", "Shoreline Type")
            checkField(geomorphology, "RANK")
            cur = gp.UpdateCursor(geomorphology)
            row = cur.Next()
            while row:
                RankValue = row.GetValue("RANK")
                if RankValue <> 1 and RankValue <> 2 and RankValue <> 3 and RankValue <> 4 and RankValue <> 5:
                    row.SetValue("RANK", 3)
                cur.UpdateRow(row)
                row = cur.next()
            del row
            del cur
        if comarg:
            checkGeometry(comarg, "Polygon", "Continental Shelf")
        if SeaLevRise:
            checkGeometry(SeaLevRise, "Polygon", "Feature Indicating Net Rise or Decrease")
    except:
        gp.AddError(msgCheckGeom)
        raise Exception

    try:
        # check that inputs are projected and in meters
        inputs = [DEM, geomorphology, SeaLevRise]
        for x in inputs:
            if gp.Exists(x):
                ckProjection(x)
    except:
        gp.AddError(msgCheckProjection)
        raise Exception

    try:
        # check that AOI intersects the continental shelf and WW3 points
        gp.MakeFeatureLayer_management(aoi_prj, aoi_lyr, "", "", "")
        gp.MakeFeatureLayer_management(WW3_Pts, WW3_Pts_lyr, "", "", "")
        SelectWW3 = gp.SelectLayerByLocation(aoi_lyr, "INTERSECT", WW3_Pts_lyr, "", "NEW_SELECTION")
        if gp.GetCount(SelectWW3) > 0:
            pass
        else:
            gp.AddError("The input AOI boundary does not intersect the Wave Watch 3 model data.\nResize the AOI to overlap with relevant data and rerun the fetch calculator.")
            raise Exception

        if comarg:
            gp.MakeFeatureLayer_management(comarg, comarg_lyr, "", "", "")
            SelectComarg = gp.SelectLayerByLocation(aoi_lyr, "INTERSECT", comarg_lyr, "", "NEW_SELECTION")
            if gp.GetCount(SelectComarg) > 0:
                pass
            else:
                gp.AddError("The input AOI boundary does not intersect the continental shelf.\nResize the AOI to overlap with relevant areas of the continental shelf and rerun the fetch calculator.")
                raise Exception
            
        # clear selection from checks
        gp.SelectLayerByAttribute(aoi_lyr, "CLEAR_SELECTION", "")
    except:
        gp.AddError(msgAOIintersect)
        raise Exception


    try:
        # read fetch threshold distance from a text file
        txtfile = open(fetch_threshDist, "r")
        line = txtfile.readline()
        FetchDistThresh = int(line)
        txtfile.close()
    except:
        gp.AddError(msgFetchThreshDist)
        raise Exception


    # reset extent to land and sea raster
    gp.Extent = landsea_rst
    gp.CopyRaster_management(fetch_cmb, fetch_cmb1, "", "", "", "", "")

    # determine if more than 50% of coastline segments are exposed
    Exposed50Pct = "false"
    FFiltList = []
    cur = gp.UpdateCursor(fetch_cmb1)
    row = cur.Next()
    while row:
        CellCount = int(row.GetValue("COUNT"))
        for i in range(CellCount):
            FFiltList.append(row.GetValue("FFILT"))
        cur.UpdateRow(row)
        row = cur.next()
    del row
    del cur

    OneCount = float(FFiltList.count(1)) # exposed coastline pixels
    LengthFFiltList = float(len(FFiltList))
    FFiltPct = float((OneCount/LengthFFiltList)*100.0)
    if FFiltPct > 50.0:
        Exposed50Pct = "true"
        gp.AddMessage("...based on the fetch threshold setting, MORE THAN 50% of coastline (within AOI) is exposed.") 
    else:
        gp.AddMessage("...based on the fetch threshold setting, LESS THAN 50% of coastline (within AOI) is exposed.") 

    # grab projection and cellsize from fetch calculator output
    projection = grabProjection(fetch_cmb1)
    cellsize = getCellSize(fetch_cmb1)

    try:
        # read in index parameters from Excel
        xlApp = Dispatch("Excel.Application")
        xlApp.Visible = 0
        xlApp.DisplayAlerts=0
        xlBook1 = xlApp.Workbooks.Open(HabLayersTable[:-(1+len(HabLayersTable.split("\\")[-1]))])
        xlSheet1 = xlBook1.Worksheets("NatHab")
        HabInputCount = xlSheet1.Cells(10,2).Value
        HabRankList = []
        HabDistList = []
        row = 2
        while row < 10:
            if xlSheet1.Cells(row, 1).Value <> None and xlSheet1.Cells(row, 1).Value <> '':
                if xlSheet1.Cells(row, 2).Value <> None and xlSheet1.Cells(row, 2).Value <> ''\
                and xlSheet1.Cells(row, 3).Value <> None and xlSheet1.Cells(row, 3).Value <> ''\
                and xlSheet1.Cells(row, 4).Value <> None and xlSheet1.Cells(row, 4).Value <> '':
                    HabRankList.append(xlSheet1.Cells(row,3).Value)
                    HabDistList.append(xlSheet1.Cells(row,4).Value)
            row += 1
        xlApp.ActiveWorkbook.Close(SaveChanges=0)
        xlApp.Quit()
        del xlApp
    except:
        gp.AddError(msgNatHabLayersTable)
        raise Exception


    try:
        if HabDirectory:
            gp.AddMessage("\nIncorporating natural habitat...")
            gp.workspace = HabDirectory
            fcList = gp.ListFeatureClasses("*", "all")
            fc = fcList.Next()
            HabLyrList = []
            HabLyrAbbrevList = []
            HabIDList = []
            HabCount = 0
            while fc:
                # match SS ID with naming convention (_ID)
                checkGeometry(fc, "Polygon", "Natural Habitat")
                checkInteger(fc)
                ckProjection(fc)
                HabLyrList.append(fc) 
                fc0 = fc.replace(".", "")
                fc1 = fc0.replace("_", "")
                HabLyrAbbrevList.append(fc1[:8]) 
                fc2 = fc[::-1]
                j = fc2.find('_')
                indexS = len(fc)-j-1
                indexE = fc.find(".")
                fc_ID = fc[indexS+1:indexE]
                HabIDList.append(int(fc_ID))
                fc = fcList.Next()
                HabCount = HabCount + 1
            del fc

            HabZip = zip(HabIDList, HabLyrList, HabLyrAbbrevList)
            HabZip.sort()
            HabIDList, HabLyrList, HabLyrAbbrevList = zip(*HabZip)

            # check consistency with spreadsheet
            if HabInputCount <> HabCount:
                gp.AddError("There is an inconsistency between the number of habitat layers in the specified directory and the input spreadsheet.")
                raise Exception

            gp.workspace = interws
         
            # search for biogenic influence on coastline
            habName = "nat_hab"
            habPath = os.path.join(interws, habName)
            gp.CreateFolder_management(interws, habName)

            # rasterize the layers and generate zone of influence                
            for i in range(0,len(HabLyrList)):
                HabVector = HabDirectory+"\\"+HabLyrList[i]
                HabVector = AddField(HabVector, "ID", "SHORT", "0", "0")
                gp.CalculateField_management(HabVector, "ID", 1, "VB")
                gp.FeatureToRaster_conversion(HabVector, "ID", habPath+"\\"+HabLyrAbbrevList[i], "50") ## -> CELLSIZE?
                WedgeExpr = "Circle "+str(HabDistList[i])+" MAP"
                gp.FocalStatistics_sa(habPath+"\\"+HabLyrAbbrevList[i], habPath+"\\"+HabLyrAbbrevList[i]+"_fs", WedgeExpr, "MEAN", "DATA")
                # reclassify natural habitat based on rank
                gp.Reclassify_sa(habPath+"\\"+HabLyrAbbrevList[i]+"_fs", "VALUE", "1 "+str(int(HabRankList[i])), habPath+"\\"+HabLyrAbbrevList[i]+"_rc", "DATA")

            MergeExpr = habPath+"\\"+HabLyrAbbrevList[0]+"_rc"
            for i in range(1,len(HabLyrAbbrevList)):        
                MergeExpr = MergeExpr + ";"+habPath+"\\"+HabLyrAbbrevList[i]+"_rc"
            gp.MosaicToNewRaster_management(MergeExpr, gp.workspace, "hab_merge", projection, "8_BIT_UNSIGNED", "", "1", "MINIMUM", "FIRST")
            gp.IsNull_sa(hab_merge, hab_nodata)
            gp.Con_sa(hab_nodata, hab_merge, hab_rank, "5", "VALUE = 0")
                       
    except:
        gp.AddError(msgBiogenicHab)
        raise Exceptions


    try: 
        if comarg:
            # calculate distance to shelf
            gp.AddMessage("\nCalculating distance to continental shelf for surge potential...")
            gp.Project_management(comarg, comarg_prj, projection)
            comarg_prj = AddField(comarg_prj, "ID", "SHORT", "0", "0")
            gp.CalculateField_management(comarg_prj, "ID", 1, "VB")
            gp.FeatureToRaster_conversion(comarg_prj, "ID", comarg_rst, str(cellsize))
            gp.CostDistance_sa(comarg_rst, costsurf_e, costdist, "",  "")
            gp.MosaicToNewRaster_management(costdist+";"+aoi_rst, interws, "costdist_rc", projection, "32_BIT_FLOAT", "", "1", "MAXIMUM", "FIRST")
            gp.Lookup_sa(fetch_cmb, "FFILT", ffilt)
            gp.RasterToPoint_conversion(ffilt, ffilt_Pts)
            gp.Select_analysis(ffilt_Pts, ffilt_Pts_select, "\"GRID_CODE\" = 1")
            gp.CostAllocation_sa(ffilt_Pts_select, costsurf_e, costd_alloc, "", "", "POINTID", "", "")
            gp.ExtractValuesToPoints_sa(ffilt_Pts_select, costdist_rc, ffilt_Pts_cd, "NONE", "VALUE_ONLY")

            FID_ExpList = []
            CostDist_ExpList = []
            cur = gp.UpdateCursor(ffilt_Pts_cd)
            row = cur.Next()
            while row:
                FID_ExpList.append(row.GetValue("POINTID"))
                CostDist_ExpList.append(row.GetValue("RASTERVALU"))
                cur.UpdateRow(row)
                row = cur.next()
            del row
            del cur
    except:
        gp.AddError(msgDistShelf)
        raise Exception


    try:
        if geomorphology:
            # prep geomorphology input for coastline output
            gp.AddMessage("\nIncorporating geomorphology...")
            gp.FeatureToRaster_conversion(geomorphology, "RANK", sz_rst, str(cellsize))
            gp.Expand_sa(sz_rst, sz_e, "2", "1;2;3;4;5")
            gp.Reclassify_sa(sz_e, "VALUE", "1 1;NODATA 0", sz_rc, "DATA")
    except:
        gp.AddError(msgGeomorph)
        raise Exception

    gp.cellsize = cellsize

    try:
        if DEM:
            # calculate coastal relief
            gp.AddMessage("\nCalculating coastal relief...")
            gp.SetNull_sa(DEM, DEM, dem_land, "\"VALUE\" <= 0")
            gp.FocalStatistics_sa(dem_land, relief_fs, "Rectangle 1500 1500 MAP", "MEAN", "DATA")
            gp.Int_sa(relief_fs, relief_int)
            gp.Reclassify_sa(relief_int, "VALUE", "1 1;NODATA 0", relief_rc, "DATA")
    except:
        gp.AddError(msgCoastalRelief)
        raise Exception


    try:
        if SeaLevRise:
            # allocate sea level rise input
            gp.AddMessage("\nAssigning areas prone to sea level rise and decline...")
            gp.FeatureToRaster_conversion(SeaLevRise, "RANK", slr_rst, str(cellsize))
            gp.Reclassify_sa(slr_rst, "VALUE", "1 1;NODATA 0", slr_rank, "DATA")
    except:
        gp.AddError(msgSeaLevRise)
        raise Exception

    try:
        # allocate wind and wave input
        gp.AddMessage("\nDetermining wind and wave exposure...")
        gp.Clip_analysis(WW3_Pts, aoi_prj, WW3_Pts_clip, "")
        gp.Project_management(WW3_Pts_clip, WW3_Pts_prj, projection)
        WW3_Pts_prj = AddField(WW3_Pts_prj, "VID", "LONG", "0", "0")
        gp.CalculateField_management(WW3_Pts_prj, "VID", "[FID]", "VB")
        gp.CostAllocation_sa(WW3_Pts_prj, costsurf_e, costa_ww3, "", "", "VID", "", "")
        Count_WW3Pts = gp.GetCount_management(WW3_Pts_prj)
        WW3List = numpy.zeros(Count_WW3Pts*50, dtype=numpy.float64)
        WW3Array = numpy.reshape(WW3List, (Count_WW3Pts,50))

        # current fetch directions
        dirCapList = ["DIR000_E", "DIR022_E", "DIR045_E", "DIR067_E", "DIR090_E", \
                      "DIR112_E", "DIR135_E", "DIR157_E", "DIR180_E", "DIR202_E", \
                      "DIR225_E", "DIR247_E", "DIR270_E", "DIR292_E", "DIR315_E", "DIR337_E"]

        gp.Mask = coast_rst
        gp.snapRaster = coast_rst
        CmbExpr = costa_ww3+";"+costdist_rc+";"+costd_alloc
        for i in range(0,len(dirCapList)):
            CmbExpr = CmbExpr+";"+FetchFolder+dirCapList[i]

        gp.Combine_sa(CmbExpr, fetch_cmb2)

        # list for the 16 directions (used for fetch and wind calculations)
        inp2 = [0, 22, 45, 67, 90, 112, 135, 157, 180, 202, 225, 247, 270, 292, 315, 337]
        # run through rows and assign values to an array
        cur = gp.UpdateCursor(WW3_Pts_prj)
        row = cur.Next()
        i = 0
        while row:
            for j in range(0,16):
                WW3Array[i][j] = row.GetValue("REI_V"+str(inp2[j]))
            for j in range(16,32):
                WW3Array[i][j] = row.GetValue("REI_PCT"+str(inp2[j-16]))
            for j in range(32,48):
                WW3Array[i][j] = row.GetValue("V10PCT_"+str(inp2[j-32]))
            j = 48
            WW3Array[i][j] = row.GetValue("W_POWER")
            j = 49
            WW3Array[i][j] = row.GetValue("VID")
            cur.UpdateRow(row)
            row = cur.next()
            i = i + 1
        del row
        del cur
    
    except:
        gp.AddError(msgCostAlloc)
        raise Exception

    try:
        # add fields
        fetch_cmb2 = AddField(fetch_cmb2, "REI_T5", "FLOAT", "", "")
        fetch_cmb2 = AddField(fetch_cmb2, "HS", "FLOAT", "", "")
        fetch_cmb2 = AddField(fetch_cmb2, "TP", "FLOAT", "", "")
        fetch_cmb2 = AddField(fetch_cmb2, "WP_WIND", "FLOAT", "", "")
        fetch_cmb2 = AddField(fetch_cmb2, "WP_WAVE", "FLOAT", "", "")
        fetch_cmb2 = AddField(fetch_cmb2, "FFILT", "SHORT", "", "")
        if comarg:
            fetch_cmb2 = AddField(fetch_cmb2, "DISTSHELF", "LONG", "", "")

        # wave power from fetch not WW3
        minWW3WP = 1000.0
        cur = gp.UpdateCursor(fetch_cmb2)
        row = cur.Next()
        while row:
            WW3_rowIndex = row.GetValue("COSTA_WW3")
            
            # wave height and period calcs
            HList = numpy.zeros(16, dtype=numpy.float64)
            TList = numpy.zeros(16, dtype=numpy.float64)
            
            # determine average wave height and wave period          
            for k in range(0,16):
                if WW3Array[WW3_rowIndex][k+32] == 0:
                    HList[k] = 0.0
                    TList[k] = 0.0
                else:
                    HList[k] = ((numpy.tanh((0.000414*((9.81*row.GetValue(dirCapList[k]))/(WW3Array[WW3_rowIndex][k+32]**2))**0.79)))**0.572)*((0.24*(WW3Array[WW3_rowIndex][k+32]**2))/9.81)
                    TList[k] = ((numpy.tanh((0.000000277*((9.81*row.GetValue(dirCapList[k]))/(WW3Array[WW3_rowIndex][k+32] **2))**1.45)))**0.187)*((7.69*WW3Array[WW3_rowIndex][k+32])/9.81)

            # get mean of HList and TList
            SumH = numpy.sum(HList)
            HList2 = list(HList)
            HListZeroCount = HList2.count(0.0)
            if HListZeroCount == 16:
                MeanH = 0.0
            else:
                MeanH = (SumH / (16.0 - HListZeroCount))
                
            SumT = numpy.sum(TList)
            TList2 = list(TList)
            TListZeroCount = TList2.count(0.0)
            if TListZeroCount == 16:
                MeanT = 0.0
            else:
                MeanT = (SumT / (16.0 - TListZeroCount))

            # wave power calcs: sort wave power list; take mean of top 3
            WavePowerList = []
            for n in range(0,len(HList)):
                WavePowerList.append((HList[n]**2)*TList[n]*0.5)
            WavePowerList.sort()
            WavePowerTop3List = WavePowerList[-3:]
            MeanWavePower = numpy.sum(WavePowerTop3List)
          
            # REI (average top 5% wind speed)
            REI_Top5 = 0.0
            for j in range(0,16):
                # REI = speed (v) * pct * fetch
                REI_Top5 = REI_Top5 + float((WW3Array[WW3_rowIndex][j])*(WW3Array[WW3_rowIndex][j+16])*(row.GetValue(dirCapList[j])))

            # for all coastline pixels
            row.SetValue("REI_T5", REI_Top5)
            row.SetValue("HS", MeanH)

            count = 0
            for i in range(0,len(dirCapList)):
                if int(row.GetValue(dirCapList[i])) >= FetchDistThresh:
                    count = count + 1

            if count == 0 or count == 1:
                row.SetValue("FFILT", 0) # unexposed
                row.SetValue("WP_WIND", MeanWavePower) # WP from wind calcs
                if comarg:
                    CostDist_index = FID_ExpList.index(row.GetValue("COSTD_ALLOC"))
                    row.SetValue("DISTSHELF", CostDist_ExpList[CostDist_index])
            else:
                row.SetValue("FFILT", 1) # exposed/WP from wave pts        
                row.SetValue("WP_WAVE", WW3Array[WW3_rowIndex][48]) # WP from WW3
                row.SetValue("WP_WIND", MeanWavePower) # WP from wind calcs
                if comarg:
                    row.SetValue("DISTSHELF", row.GetValue("COSTDIST_RC"))

            # determine the minimum WP value from WW3
            if row.GetValue("WP_WAVE") > 0.0:
                if minWW3WP > row.GetValue("WP_WAVE"):
                    minWW3WP = row.GetValue("WP_WAVE")

            cur.UpdateRow(row)
            row = cur.next()
        del row
        del cur

    except:
        gp.AddError(msgWindWaveExposure)
        raise Exception

    try:
        WindExpList = []
        WaveExpList = []
        if comarg:
            SurgeList = []
            
        cur = gp.UpdateCursor(fetch_cmb2)
        row = cur.Next()
        while row:
            CellCount = int(row.GetValue("COUNT"))
            for i in range(CellCount):
                WindExpList.append(row.GetValue("REI_T5"))
            if comarg:
                for i in range(CellCount):
                    SurgeList.append(row.GetValue("DISTSHELF"))  

            if Exposed50Pct == "false":
                for i in range(CellCount):
                    WaveExpList.append(row.GetValue("WP_WIND"))
                    
            if Exposed50Pct == "true":
                if int(row.GetValue("FFILT")) == 0 and row.GetValue("WP_WIND") > minWW3WP:
                    for i in range(CellCount):
                        WaveExpList.append(row.GetValue("WP_WIND"))
                if int(row.GetValue("FFILT")) == 1:
                    for i in range(CellCount):
                        WaveExpList.append(row.GetValue("WP_WAVE"))

            cur.UpdateRow(row)
            row = cur.next()
        del row
        del cur

        fetch_cmb2 = AddField(fetch_cmb2, "WIND_RANK", "LONG", "", "")
        fetch_cmb2 = AddField(fetch_cmb2, "WAVE_RANK", "LONG", "", "")
        WindExpPctList = getPercentiles(WindExpList)
        WaveExpPctList = getPercentiles(WaveExpList)
        if comarg:
            fetch_cmb2 = AddField(fetch_cmb2, "SURGE_RANK", "LONG", "", "")
            SurgePctList = getPercentiles(SurgeList)

        cur = gp.UpdateCursor(fetch_cmb2)
        row = cur.Next()
        while row:
            # wind ranks
            REI_T5 = row.GetValue("REI_T5")
            if REI_T5 < WindExpPctList[0]:
                row.SetValue("WIND_RANK", 1)
            elif REI_T5 >= WindExpPctList[0] and REI_T5 < WindExpPctList[1]:
                row.SetValue("WIND_RANK", 2)
            elif REI_T5 >= WindExpPctList[1] and REI_T5 <= WindExpPctList[3]:
                row.SetValue("WIND_RANK", 3)
            elif REI_T5 >= WindExpPctList[3] and REI_T5 <= WindExpPctList[4]:
                row.SetValue("WIND_RANK", 4)
            elif REI_T5 > WindExpPctList[4]:
                row.SetValue("WIND_RANK", 5)

            # wave ranks
            if Exposed50Pct == "true":
                if row.GetValue("FFILT") == 0 and row.GetValue("WP_WIND") <= minWW3WP:
                    row.SetValue("WAVE_RANK", 1)
                else:
                    if row.GetValue("FFILT") == 0 and row.GetValue("WP_WIND") > minWW3WP:
                        WavePower = row.GetValue("WP_WIND")
                    else:   
                        WavePower = row.GetValue("WP_WAVE")

                    if WavePower < WaveExpPctList[1]:
                        row.SetValue("WAVE_RANK", 2)
                    if WavePower >= WaveExpPctList[1] and WavePower <= WaveExpPctList[3]:
                        row.SetValue("WAVE_RANK", 3)
                    if WavePower >= WaveExpPctList[3] and WavePower <= WaveExpPctList[4]:
                        row.SetValue("WAVE_RANK", 4)
                    if WavePower > WaveExpPctList[4]:
                        row.SetValue("WAVE_RANK", 5)

            if Exposed50Pct == "false":
                WavePowerFetch = row.GetValue("WP_WIND")
                if WavePowerFetch < WaveExpPctList[0]:
                    row.SetValue("WAVE_RANK", 1)
                elif WavePowerFetch >= WaveExpPctList[0] and WavePowerFetch < WaveExpPctList[1]:
                    row.SetValue("WAVE_RANK", 2)
                elif WavePowerFetch >= WaveExpPctList[1] and WavePowerFetch <= WaveExpPctList[3]:
                    row.SetValue("WAVE_RANK", 3)
                elif WavePowerFetch >= WaveExpPctList[3] and WavePowerFetch <= WaveExpPctList[4]:
                    row.SetValue("WAVE_RANK", 4)
                else:
                    row.SetValue("WAVE_RANK", 5)

            # dist to shelf ranks                
            if comarg:
                DistShelf = row.GetValue("DISTSHELF")
                if DistShelf < SurgePctList[0]:
                    row.SetValue("SURGE_RANK", 1)
                elif DistShelf >= SurgePctList[0] and DistShelf < SurgePctList[1]:
                    row.SetValue("SURGE_RANK", 2)
                elif DistShelf >= SurgePctList[1] and DistShelf <= SurgePctList[3]:
                    row.SetValue("SURGE_RANK", 3)
                elif DistShelf >= SurgePctList[3] and DistShelf <= SurgePctList[4]:
                    row.SetValue("SURGE_RANK", 4)
                else:
                    row.SetValue("SURGE_RANK", 5)

            cur.UpdateRow(row)
            row = cur.next()
        del row
        del cur

        gp.Lookup_sa(fetch_cmb2, "WIND_RANK", wind_rank)
        gp.Lookup_sa(fetch_cmb2, "WAVE_RANK", wave_rank)
        if comarg:
            gp.Lookup_sa(fetch_cmb2, "SURGE_RANK", surge_rank)
    except:
        gp.AddError(msgRankingWWS)
        raise Exception

    try:
        # combine various index rasters
        gp.AddMessage("\nCombining results and generating outputs...")    

        CmbExpr = ffilt+";"+wind_rank+";"+wave_rank
        if HabDirectory:
            CmbExpr = CmbExpr+";"+hab_rank
        if geomorphology:
            CmbExpr = CmbExpr+";"+sz_rc
        if comarg:
            CmbExpr = CmbExpr+";"+surge_rank
        if DEM:
            CmbExpr = CmbExpr+";"+relief_rc
        if SeaLevRise:
            CmbExpr = CmbExpr+";"+slr_rank

        gp.Combine_sa(CmbExpr, exp_index)
        
    except:
        gp.AddError(msgCombineIndex)
        raise Exception


    try:
        if globalPop:
            gp.AddMessage("...extracting coastal population")
            gp.ProjectRaster_management(globalPop, pop_prj, projection, "BILINEAR", "250", "", "", "")
            gp.ExtractByMask_sa(pop_prj, exp_index, coast_pop)
            gp.Reclassify_sa(coast_pop, "VALUE", "0 NODATA", coast_pop_rc, "DATA")
            gp.RasterToPoint_conversion(coast_pop_rc, coast_pop_Pts)

            costPopList = []
            cur = gp.UpdateCursor(coast_pop_Pts)
            row = cur.Next()
            while row:
                if row.GetValue("GRID_CODE") > 0:
                    costPopList.append(row.GetValue("GRID_CODE"))
                cur.UpdateRow(row)
                row = cur.next()
            del row
            del cur

            # creates a list for breaks (10, 25, 50, 75, 90)
            coastPopList = getPercentiles(costPopList)
            coast_pop_Pts = AddField(coast_pop_Pts, "POP_BREAK", "SHORT", "", "")
            coast_pop_Pts = AddField(coast_pop_Pts, "POP_RANGE", "TEXT", "30", "")
            coast_pop_Pts = AddField(coast_pop_Pts, "VAL_BREAKS", "TEXT", "50", "")

            cur = gp.UpdateCursor(coast_pop_Pts, "", "", "POP_BREAK; POP_RANGE; VAL_BREAKS; GRID_CODE")
            row = cur.Next()
            while row:
                if row.GRID_CODE < coastPopList[1]:
                    row.SetValue("POP_BREAK", 1)
                    row.SetValue("POP_RANGE", "< 25th Pctile")
                    row.SetValue("VAL_BREAKS", "Population < "+str(int(coastPopList[1]))+" People")
                if row.GRID_CODE >= coastPopList[1] and row.GRID_CODE <= coastPopList[2]:
                    row.SetValue("POP_BREAK", 2)
                    row.SetValue("POP_RANGE", "25-50th Pctile")
                    row.SetValue("VAL_BREAKS", str(int(coastPopList[1]))+" <= Population < "+str(int(coastPopList[2]))+" People")
                if row.GRID_CODE >= coastPopList[2] and row.GRID_CODE <= coastPopList[3]:
                    row.SetValue("POP_BREAK", 3)
                    row.SetValue("POP_RANGE", "50-75th Pctile")
                    row.SetValue("VAL_BREAKS", str(int(coastPopList[2]))+" <= Population < "+str(int(coastPopList[3]))+" People")
                if row.GRID_CODE > coastPopList[3]:
                    row.SetValue("POP_BREAK", 4)
                    row.SetValue("POP_RANGE", "> 75th Pctile")
                    row.SetValue("VAL_BREAKS", "Population >= "+str(int(coastPopList[3]))+" People")
                cur.UpdateRow(row)
                row = cur.next()
            del row
            del cur
    except:
        gp.AddError(msgPopulationCalcs)
        raise Exception


    if DEM:
        ReliefList = []
        cur = gp.UpdateCursor(exp_index)
        row = cur.Next()
        while row:
            CellCount = int(row.GetValue("COUNT"))
            for i in range(CellCount):
                if row.GetValue("RELIEF_RC") <> 0:
                    ReliefList.append(row.GetValue("RELIEF_RC"))
            cur.UpdateRow(row)
            row = cur.next()
        del row
        del cur
        
        ReliefPctList = getPercentiles(ReliefList)
        exp_index = AddField(exp_index, "RELF_RANK", "SHORT", "", "")

    if geomorphology:
        exp_index = AddField(exp_index, "GMRPH_RANK", "SHORT", "", "")
        
    try:
        # add final fields
        if HabDirectory and geomorphology:
            exp_index = AddField(exp_index, "EI", "FLOAT", "", "")
        if HabDirectory and geomorphology and comarg and SeaLevRise:
            exp_index = AddField(exp_index, "II", "FLOAT", "", "")
        exp_index = AddField(exp_index, "VI", "FLOAT", "", "")
        
        gp.AddMessage("...computing exposure indices")
        cur = gp.UpdateCursor(exp_index)
        row = cur.Next()
        while row:
            if geomorphology:
                if row.GetValue("SZ_RC") == 0:
                    row.SetValue("GMRPH_RANK", 3)
                else:
                    geomorphRank = row.GetValue("SZ_RC")
                    row.SetValue("GMRPH_RANK", geomorphRank)

            if DEM:
                ReliefValue = row.GetValue("RELIEF_RC")
                if ReliefValue == 0:
                    row.SetValue("RELF_RANK", 3)
                if ReliefValue < ReliefPctList[0] and ReliefValue <> 0:
                    row.SetValue("RELF_RANK", 5)
                if ReliefValue >= ReliefPctList[0] and ReliefValue < ReliefPctList[1]:
                    row.SetValue("RELF_RANK", 4)
                if ReliefValue >= ReliefPctList[1] and ReliefValue <= ReliefPctList[3]:
                    row.SetValue("RELF_RANK", 3)
                if ReliefValue >= ReliefPctList[3] and ReliefValue <= ReliefPctList[4]:
                    row.SetValue("RELF_RANK", 2)
                if ReliefValue > ReliefPctList[4]:
                    row.SetValue("RELF_RANK", 1)

            # calculate erosian index
            if HabDirectory and geomorphology:
                EIExpr = row.GetValue("WAVE_RANK")*row.GetValue("HAB_RANK")*row.GetValue("GMRPH_RANK")
                
            # calculate inundation index
            if HabDirectory and geomorphology and comarg and SeaLevRise:
                IIExpr = row.GetValue("WIND_RANK")*row.GetValue("HAB_RANK")*row.GetValue("RELF_RANK")*row.GetValue("SURGE_RANK")*row.GetValue("SLR_RANK")
                
            # calculate vulnerability index
            VIExpr = row.GetValue("WAVE_RANK")*row.GetValue("WIND_RANK")*row.GetValue("RELF_RANK")
            VICount = 3.0

            if HabDirectory:
                VIExpr = VIExpr*row.GetValue("HAB_RANK")
                VICount += 1

            if geomorphology:
                VIExpr = VIExpr*row.GetValue("GMRPH_RANK")
                VICount += 1

            if comarg:
                VIExpr = VIExpr*row.GetValue("SURGE_RANK")
                VICount += 1
            
            if SeaLevRise:
                VIExpr = VIExpr*row.GetValue("SLR_RANK")
                VICount += 1

            # calculate various indices
            if HabDirectory and geomorphology:
                row.SetValue("EI", (((EIExpr)**0.5)/3.0))
            if HabDirectory and geomorphology and comarg and SeaLevRise:
                row.SetValue("II", (((IIExpr)**0.5)/5.0))
            row.SetValue("VI", (((VIExpr)**0.5)/VICount))
          
            cur.UpdateRow(row)
            row = cur.next()
        del row
        del cur

        # create output with "VI" as only "value"
        if HabDirectory and geomorphology:
            gp.Lookup_sa(exp_index, "EI", eros_index)
        if HabDirectory and geomorphology and comarg and SeaLevRise:
            gp.Lookup_sa(exp_index, "II", inund_index)
        gp.Lookup_sa(exp_index, "VI", vuln_index)

        # delete "SZ_RC" and "RELIEF_RC" in attribute table
        if geomorphology:
            gp.DeleteField_management(exp_index, "SZ_RC")
        if DEM:
            gp.DeleteField_management(exp_index, "RELIEF_RC")

        # copy coastPoly from fetch calculator to coastal vulnerability output folder
        gp.CopyFeatures_management(coastPoly_prj, coastPoly_prjCopy, "", "0", "0", "0")
            
    except:
        gp.AddError(msgExposureIndex)
        raise Exception

    # create parameter file
    parameters.append("Script location: "+os.path.dirname(sys.argv[0])+"\\"+os.path.basename(sys.argv[0]))
    parafile = open(outputws+"\\parameters_"+now.strftime("%Y-%m-%d-%H-%M")+".txt","w") 
    parafile.writelines("COASTAL VULNERABILITY INDEX PARAMETERS\n")
    parafile.writelines("______________________________________\n\n")

    for para in parameters:
        parafile.writelines(para+"\n")
        parafile.writelines("\n")
    parafile.close()

    # delete superfluous intermediate data
    del1 = [sz_rst, sz_rc, sz_e, slr_rst, dem_land, relief_rc, relief_int, relief_fs, hab_merge, hab_nodata, hab_rank, coast_pop_rc]
    del2 = [pop_prj, WW3_Pts_prj, WW3_Pts_clip, costdist_rc, costdist, costd_alloc, costa_ww3, comarg_rst, comarg_prj, fetch_cmb1]
    del3 = [WW3_Pts_lyr, aoi_lyr, comarg_lyr, wind_rank, wave_rank, surge_rank, slr_rank, ffilt, ffilt_Pts, ffilt_Pts_select, ffilt_Pts_cd]
    deletelist = del1 + del2 + del3
    for data in deletelist:
        if gp.exists(data):
            gp.delete_management(data)
    del gp

except Exception, ErrorDesc:
    gp.AddMessage(gp.GetMessages())
