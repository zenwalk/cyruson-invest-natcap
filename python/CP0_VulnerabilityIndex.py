# Marine InVEST: Coastal Vulnerability Index
# Authors: Gregg Verutes, Greg Guannel, Jeremy Davies
# Coded for ArcGIS 9.3 and 10
# 01/13/12

import sys, string, os, array, time, datetime, shlex, csv
from math import *
import arcgisscripting
import fpformat, operator

# create the geoprocessor object
gp = arcgisscripting.create()

# set output handling
gp.OverwriteOutput = 1
# check out extensions
gp.CheckOutExtension("spatial")
gp.CheckOutExtension("management")
gp.CheckOutExtension("analysis")
gp.CheckOutExtension("conversion")

# error messages
msgArguments = "\nProblem with arguments."
msgCheckGeom = "\nError checking the geometry of inputs."
msgCheckDatum = "\nError checking the datum of inputs."
msgCheckProjectionWS = "\nError checking the projection and workspace of inputs."
msgAOIintersect = "\nError checking that the AOI input intersects the WW3 and continental shelf input data."
msgFetchThreshDist = "\nError reading fetch threshold distance from a text file."
msgWindWaveExposure = "\nError reading in wind and wave exposure data."
msgNatHabLayersTable = "\nError reading in natural habitat layers table."
msgBiogenicHab = "\nError incorporating biogenic habitat."
msgGeomorph = "\nError incorporating geomorphology."
msgStructure = "\nError incorporating presence of structures."
msgDistShelf = "\nError calculating distance to shelf."
msgCoastalRelief = "\nError calculating coastal relief."
msgSeaLevRise = "\nError assigning input for expected sea level rise."
msgCostAlloc = "\nError allocating WW3 model data to coastline."
msgRankingWWS = "\nError ranking wind/wave exposure and surge potential."
msgCombineIndex = "\nError combining results for exposure index."
msgPopulationCalcs = "\nError extracting coastal population."
msgExposureIndex = "\nError calculating coastal exposure index."
msgNumPyNo = "NumPy extension is required to run the Coastal Vulnerability Model.  Please consult the Marine InVEST FAQ for instructions on how to install."
msgSciPyNo = "SciPy extension is required to run the Coastal Vulnerability Model.  Please consult the Marine InVEST FAQ for instructions on how to install."

# import modules
try:
    import numpy
except:
    gp.AddError(msgNumPyNo)
    raise Exception

try:
    from scipy import stats
except:
    gp.AddError(msgSciPyNo)
    raise Exception

try:
    try:
        # get parameters
        parameters = []
        now = datetime.datetime.now()
        parameters.append("Date and Time: "+ now.strftime("%Y-%m-%d %H:%M"))
        gp.workspace = gp.GetParameterAsText(0)
        parameters.append("Workspace: "+ gp.workspace)
        gp.scratchWorkspace = gp.GetParameterAsText(0)
        parameters.append("Scratch Workspace: "+ gp.scratchWorkspace)
        FetchCalcWS = gp.GetParameterAsText(1)
        parameters.append("Fetch Calculator Tool Run Workspace: "+ FetchCalcWS)
        globalPop = gp.GetParameterAsText(2)
        parameters.append("Global Population Raster: "+ globalPop)      
        WW3_Pts = gp.GetParameterAsText(3)
        parameters.append("WIND-WAVE EXPOSURE - Wave Watch III Model Data: "+ WW3_Pts)
        AvgD = float(gp.GetParameterAsText(4))
        parameters.append("WIND-WAVE EXPOSURE - Average Depth (meters) within AOI: "+ str(AvgD))
        DEM = gp.GetParameterAsText(5)
        parameters.append("RELIEF - Digital Elevation Model (DEM): "+ DEM)
        HabDirectory = gp.GetParameterAsText(6)
        parameters.append("NATURAL HABITAT - Directory with Layers: "+ HabDirectory)
        HabLayersTable = gp.GetParameterAsText(7)
        parameters.append("NATURAL HABITAT - Layers CSV Table: "+ HabLayersTable)  
        geomorphology = gp.GetParameterAsText(8)
        parameters.append("GEOMORPHOLOGY - Shoreline Type: "+ geomorphology)
        structPoly = gp.GetParameterAsText(9)
        parameters.append("STRUCTURES: Polygons Indicating Presence of Structures: "+ structPoly)
        comarg = gp.GetParameterAsText(10)
        parameters.append("SURGE POTENTIAL - Continental Margin: "+ comarg)
        SeaLevRise = gp.GetParameterAsText(11)
        parameters.append("SEA LEVEL RISE: Zones Indicating Net Rise or Decrease: "+ SeaLevRise)

    except:
        raise Exception, msgArguments + gp.GetMessages(2)
        
    # check and create folders
    try:
        thefolders=["intermediate", "Output"]
        for folder in thefolders:
            if not gp.exists(gp.workspace + folder):
                gp.CreateFolder_management(gp.workspace, folder)
    except:
        raise Exception, "Error creating folders"

    # intermediate and output directories
    outputws = gp.workspace + os.sep + "Output" + os.sep
    interws = gp.workspace + os.sep + "intermediate" + os.sep

    # fetch calculator run variables
    aoi_prj = FetchCalcWS + os.sep + "intermediate" + os.sep + "aoi_prj.shp"
    aoi_rst = FetchCalcWS + os.sep + "intermediate" + os.sep + "aoi_rst"
    costsurf_e = FetchCalcWS + os.sep + "intermediate" + os.sep + "costsurf_e"
    coast_rst = FetchCalcWS + os.sep + "intermediate" + os.sep + "coast_rst"
    landsea_rst = FetchCalcWS + os.sep + "intermediate" + os.sep + "landsea_rst"
    FetchFolder = FetchCalcWS + os.sep + "intermediate" + os.sep + "fetch" + os.sep
    fetch_cmb = FetchCalcWS + os.sep + "Output" + os.sep + "fetch_cmb"
    coastPoly_prj = FetchCalcWS + os.sep + "Output" + os.sep + "coastPoly_prj.shp"
    fetch_threshDist = FetchCalcWS + os.sep + "Output" + os.sep + "fetch_threshDist.txt"

    # prep variables
    WW3_Pts_lyr = interws + "WW3_Pts_lyr.lyr" 
    aoi_lyr = interws + "aoi_lyr.lyr"
    comarg_lyr = interws + "comarg_lyr.lyr"
    pop_prj = interws + "pop_prj"
    coast_pop_rc = interws + "coast_pop_rc"

    # exposure index variables
    fetch_cmb1 = interws + "fetch_cmb1"
    fetch_cmb2 = interws + "fetch_cmb2"
    wind_rank = interws + "wind_rank"
    wave_rank = interws + "wave_rank"
    surge_rank = interws + "surge_rank"
    ffilt = interws + "ffilt"
    ffilt_Pts = interws + "ffilt_pts.shp"
    ffilt_Pts_select = interws + "ffilt_pts_select.shp"
    ffilt_Pts_cd = interws + "ffilt_pts_cd.shp"
    costd_alloc = interws + "costd_alloc"
    hab_merge = interws + "hab_merge"
    hab_nodata = interws + "hab_nodata"
    hab_rank = interws + "hab_rank"
    gmorph_rst = interws + "gmorph_rst"
    gmorph_e = interws + "gmorph_e"
    gmorph_rc = interws + "gmorph_rc"
    structures = interws + "structures.shp"
    struct_rst = interws + "struct_rst"
    struct_rst2 = interws + "struct_rst2"
    struct_e = interws + "struct_e"
    struct_e2 = interws + "struct_e2"
    structure = interws + "structure"
    comarg_prj = interws + "comarg_prj.shp"
    comarg_rst = interws + "comarg_rst"
    costdist = interws + "costdist"
    costdist_rc = interws + "costdist_rc"
    dem_land = interws + "dem_land"
    relief_fs = interws + "relief_fs"
    relief_int = interws + "relief_int"
    relief_rc = interws + "relief_rc"
    slr_rst = interws + "slr_rst" 
    slr_rank = interws + "slr_rank"
    costa_ww3 = interws + "costa_ww3"
    WW3_Pts_clip = interws + "WW3_Pts_clip.shp"
    WW3_Pts_prj = interws + "WW3_Pts_prj.shp"

    # output variables
    coastPoly_prjCopy = outputws + "coastPoly_prj.shp" 
    coast_pop = outputws + "coast_pop"
    coast_pop_Pts = outputws + "coast_pop_Pts.shp"
    exp_index = outputws + "exp_index"
    eros_index = outputws + "eros_index"
    inund_index = outputws + "inund_index"
    vuln_index = outputws + "vuln_index"


    ##############################################
    ###### COMMON FUNCTION AND CHECK INPUTS ######
    ##############################################

    def checkGeometry(thedata, Type, Message):
        if gp.Describe(thedata).ShapeType == Type:
            raise Exception, "\nInvalid input: "+thedata+"\n"+Message+" cannot be of geometry type "+Type+"."

    def checkDatum(thedata):
        desc = gp.describe(thedata)
        SR = desc.SpatialReference
        if SR.Type == "Geographic":
            strDatum = SR.DatumName         
        else:
            gp.OutputCoordinateSystem = SR
            strSR = str(gp.OutputCoordinateSystem)
            gp.OutputCoordinateSystem = ""
            n1 = strSR.find("DATUM[\'")
            n2 = strSR.find("\'",n1+7)
            strDatum = strSR[n1+7:n2]
        if strDatum == "D_WGS_1984":
            pass
        else:
            gp.AddError(thedata+" is not a valid input.\nThe model requires an AOI input with the \"WGS84\" datum.\nPlease review InVEST FAQ guide on how to reproject datasets.")
            raise Exception

    def ckProjection(data):
        dataDesc = gp.describe(data)
        spatreflc = dataDesc.SpatialReference
        if spatreflc.Type <> 'Projected':
            gp.AddError(data +" does not appear to be projected.  It is assumed to be in meters.")
            raise Exception
        if spatreflc.LinearUnitName <> 'Meter':
            gp.AddError("This model assumes that "+data+" is projected in meters for area calculations.  You may get erroneous results.")
            raise Exception

    def grabProjection(data):
        dataDesc = gp.describe(data)
        sr = dataDesc.SpatialReference
        gp.OutputCoordinateSystem = sr
        strSR = str(gp.OutputCoordinateSystem)
        return strSR

    def AddField(FileName, FieldName, Type, Precision, Scale):
        fields = gp.ListFields(FileName, FieldName)
        field_found = fields.Next()
        if field_found:
            gp.DeleteField_management(FileName, FieldName)
        gp.AddField_management(FileName, FieldName, Type, Precision, Scale, "", "", "NON_NULLABLE", "NON_REQUIRED", "")
        return FileName

    def checkField(FileName, FieldName):
        fields = gp.ListFields(FileName, FieldName)
        field_found = fields.Next()
        if field_found:
            pass
        else:
            gp.AddError("The geomorphology input must contain a field called 'RANK' with integer values ranging from 1 to 5.")
            raise Exception

    def getCellSize(thedata):
         desc=gp.Describe(thedata)
         CellWidth = desc.MeanCellWidth
         CellHeight = desc.MeanCellHeight
         return int((CellHeight+CellWidth)/2.0)
        
    def checkInteger(thedata):
        if thedata.find("0") == -1 and thedata.find("1") == -1 and thedata.find("2") == -1 and thedata.find("3") == -1 and thedata.find("4") == -1 and thedata.find("5") == -1 and thedata.find("6") == -1 and thedata.find("7") == -1 and thedata.find("8") == -1 and thedata.find("9") == -1:
            gp.AddError(thedata +" must contain an underscore followed by an integer ID at the end of it's name (e.g. filename_1.shp). This is necessary to properly link it with the input table.")
            raise Exception

    # percentiles list (10, 25, 50, 75, 90)
    def getPercentiles(list):
        PctList = []
        PctList.append(stats.scoreatpercentile(list, 10))
        PctList.append(stats.scoreatpercentile(list, 25))
        PctList.append(stats.scoreatpercentile(list, 50))
        PctList.append(stats.scoreatpercentile(list, 75))
        PctList.append(stats.scoreatpercentile(list, 90))
        return PctList

    def iterativek(sigma, dh, g):
        kestimated = (sigma**2)/(g*(numpy.sqrt(numpy.tanh((sigma**2)*dh/g))))
        kprevious = 0.0000001
        count = 0
        while (abs(kestimated-kprevious) > 0.000005) and (count < 1000):
            count += 1
            kh = kestimated*dh
            kcalculated = (sigma**2)/(numpy.tanh(kh)*g)
            kprevious = kestimated
            kestimated = kcalculated
        qk = kcalculated
        return qk    
            
    try:
        gp.AddMessage("\nPreparing and checking inputs...")
        # check inputs
        if HabDirectory and not HabLayersTable:
            gp.AddError("\nCannot incorporate natural habitat without an associated layers table input.")
            raise Exception
        if geomorphology:
            checkField(geomorphology, "RANK")
            cur = gp.UpdateCursor(geomorphology)
            row = cur.Next()
            while row:
                RankValue = row.GetValue("RANK")
                if RankValue <> 1 and RankValue <> 2 and RankValue <> 3 and RankValue <> 4 and RankValue <> 5:
                    row.SetValue("RANK", 3)
                cur.UpdateRow(row)
                row = cur.next()
            del row, cur
    except:
        gp.AddError(msgCheckGeom)
        raise Exception

    try:
        # check that inputs are projected and in meters
        inputs = [DEM, geomorphology, SeaLevRise]
        for x in inputs:
            if gp.Exists(x):
                ckProjection(x)
                
        # check that FetchCalcWS and CV WS aren't the same
        if FetchCalcWS == gp.workspace:
            gp.AddError("Please select a workspace for the Vulnerability Index that is different from the already created Fetch Calculator workspace.")
            raise Exception
    except:
        gp.AddError(msgCheckProjectionWS)
        raise Exception

    try:
        # check that AOI intersects the continental shelf and WW3 points
        gp.MakeFeatureLayer_management(aoi_prj, aoi_lyr, "", "", "")
        gp.MakeFeatureLayer_management(WW3_Pts, WW3_Pts_lyr, "", "", "")
        SelectWW3 = gp.SelectLayerByLocation(aoi_lyr, "INTERSECT", WW3_Pts_lyr, "", "NEW_SELECTION")
        if gp.GetCount(SelectWW3) > 0:
            pass
        else:
            gp.AddError("The input AOI boundary does not intersect the Wave Watch 3 model data.\nResize the AOI to overlap with relevant data and rerun the fetch calculator.")
            raise Exception

        if comarg:
            gp.MakeFeatureLayer_management(comarg, comarg_lyr, "", "", "")
            SelectComarg = gp.SelectLayerByLocation(aoi_lyr, "INTERSECT", comarg_lyr, "", "NEW_SELECTION")
            if gp.GetCount(SelectComarg) > 0:
                pass
            else:
                gp.AddError("The input AOI boundary does not intersect the continental shelf.\nResize the AOI to overlap with relevant areas of the continental shelf and rerun the fetch calculator.")
                raise Exception
            
        # clear selection from checks
        gp.SelectLayerByAttribute(aoi_lyr, "CLEAR_SELECTION", "")
    except:
        gp.AddError(msgAOIintersect)
        raise Exception


    try:
        # read fetch threshold distance from a text file
        txtfile = open(fetch_threshDist, "r")
        line = txtfile.readline()
        FetchDistThresh = int(line)
        txtfile.close()
    except:
        gp.AddError(msgFetchThreshDist)
        raise Exception


    # reset extent to land and sea raster
    gp.Extent = landsea_rst
    gp.CopyRaster_management(fetch_cmb, fetch_cmb1, "", "", "", "", "")

    # grab projection and cellsize from fetch calculator output
    projection = grabProjection(fetch_cmb1)
    cellsize = getCellSize(fetch_cmb1)

    try:
        if HabDirectory and HabLayersTable:
            gp.AddMessage("...incorporating natural habitat")
            rawList = []
            # read in CSV to 'HabArray'
            csvReader = csv.reader(open(HabLayersTable, 'rb'), delimiter=',', quotechar='|')
            for row in csvReader:
                rawList.append(row)
            parseArray = []
            for i in range(0, len(rawList)):
                parseList = []
                for j in range(0,len(rawList[i])):
                    if rawList[i][j] <> '':
                        parseList.append(rawList[i][j])
                parseArray.append(parseList)
            HabArray = []
            for i in range(0,len(parseArray)):
                if len(parseArray[i]) == 4 and i > 0:
                    HabArray.append([float(s) for s in parseArray[i][1:]])
            HabArray.sort() # sort list by habitat ID
            HabInputCount = len(HabArray) # get count of habitat inputs from CSV
    except:
        gp.AddError(msgNatHabLayersTable)
        raise Exception

    try:
        if HabDirectory and HabLayersTable:
            gp.workspace = HabDirectory
            fcList = gp.ListFeatureClasses("*", "all")
            fc = fcList.Next()
            HabLyrList = []
            HabLyrAbbrevList = []
            HabIDList = []
            HabCount = 0
            while fc:
                # match SS ID with naming convention (_ID)
                checkGeometry(fc, "Point", "Natural Habitat")
                checkInteger(fc)
                ckProjection(fc)
                HabLyrList.append(fc) 
                fc0 = fc.replace(".", "")
                fc1 = fc0.replace("_", "")
                HabLyrAbbrevList.append(fc1[:7]) 
                fc2 = fc[::-1]
                j = fc2.find('_')
                indexS = len(fc)-j-1
                indexE = fc.find(".")
                fc_ID = fc[indexS+1:indexE]
                HabIDList.append(int(fc_ID))
                fc = fcList.Next()
                HabCount = HabCount + 1
            del fc

            HabZip = zip(HabIDList, HabLyrList, HabLyrAbbrevList)
            HabZip.sort()
            HabIDList, HabLyrList, HabLyrAbbrevList = zip(*HabZip)

            # check consistency with spreadsheet
            if HabInputCount <> HabCount:
                gp.AddError("There is an inconsistency between the number of habitat layers in the specified directory and the input spreadsheet.")
                raise Exception

            gp.workspace = interws
         
            # search for biogenic influence on coastline
            habName = "nat_hab"
            habPath = os.path.join(interws, habName)
            gp.CreateFolder_management(interws, habName)

            # rasterize the layers and generate zone of influence                
            for i in range(0,len(HabLyrList)):
                HabVector = HabDirectory+"\\"+HabLyrList[i]
                HabVector = AddField(HabVector, "VID", "SHORT", "0", "0")
                gp.CalculateField_management(HabVector, "VID", 1, "VB")
                gp.FeatureToRaster_conversion(HabVector, "VID", habPath+"\\"+HabLyrAbbrevList[i], "50")
                gp.Expand_sa(habPath+"\\"+HabLyrAbbrevList[i], habPath+"\\"+HabLyrAbbrevList[i]+"_e", str(int(HabArray[i][2]/50)), "1")
                # reclassify natural habitat based on rank
                gp.Reclassify_sa(habPath+"\\"+HabLyrAbbrevList[i]+"_e", "VALUE", "1 "+str(int(HabArray[i][1]))+";NODATA 0", habPath+"\\"+HabLyrAbbrevList[i]+"_rc", "DATA")                 
    except:
        gp.AddError(msgBiogenicHab)
        raise Exceptions


    try: 
        if comarg:
            gp.AddMessage("...calculating distance to continental shelf for surge potential")
            gp.Project_management(comarg, comarg_prj, projection)
            comarg_prj = AddField(comarg_prj, "VID", "SHORT", "0", "0")
            gp.CalculateField_management(comarg_prj, "VID", 1, "VB")
            gp.FeatureToRaster_conversion(comarg_prj, "VID", comarg_rst, str(cellsize))
            gp.CostDistance_sa(comarg_rst, costsurf_e, costdist, "",  "")
            gp.MosaicToNewRaster_management(costdist+";"+aoi_rst, interws, "costdist_rc", projection, "32_BIT_SIGNED", "", "1", "MAXIMUM", "FIRST")
    except:
        gp.AddError(msgDistShelf)
        raise Exception

    try:
        if geomorphology:
            gp.AddMessage("...incorporating coastal geomorphology")
            gp.FeatureToRaster_conversion(geomorphology, "RANK", gmorph_rst, str(cellsize))
            gp.Expand_sa(gmorph_rst, gmorph_e, "2", "1;2;3;4;5")
            gp.Reclassify_sa(gmorph_rst, "VALUE", "1 1;NODATA 0", gmorph_rc, "DATA")
    except:
        gp.AddError(msgGeomorph)
        raise Exception

    try:
        if structPoly:
            gp.AddMessage("...adding the effect of structures")
            structPoly = AddField(structPoly, "VID", "SHORT", "0", "0")
            gp.CalculateField_management(structPoly, "VID", 1, "VB")        
            gp.FeatureToRaster_conversion(structPoly, "VID", struct_rst, str(cellsize))
            gp.Reclassify_sa(struct_rst, "VALUE", "1 1;NODATA 0", struct_rst2, "DATA")    
            gp.Expand_sa(struct_rst, struct_e, "1", "1")
            gp.Reclassify_sa(struct_e, "VALUE", "1 1;NODATA 0", struct_e2, "DATA")
            gp.Minus_sa(struct_e2, struct_rst2, structure)
    except:
        gp.AddError(msgStructure)
        raise Exception

    gp.cellsize = cellsize

    try:
        if DEM:
            gp.AddMessage("...calculating coastal relief")
            gp.SetNull_sa(DEM, DEM, dem_land, "\"VALUE\" <= 0")
            gp.FocalStatistics_sa(dem_land, relief_fs, "Rectangle 1500 1500 MAP", "MEAN", "DATA")
            gp.Int_sa(relief_fs, relief_int)
            gp.Reclassify_sa(relief_int, "VALUE", "1 1;NODATA 0", relief_rc, "DATA")
    except:
        gp.AddError(msgCoastalRelief)
        raise Exception

    try:
        if SeaLevRise:
            gp.AddMessage("...assigning areas prone to sea level rise and decline")
            gp.FeatureToRaster_conversion(SeaLevRise, "RANK", slr_rst, str(cellsize))
            gp.Reclassify_sa(slr_rst, "VALUE", "1 1;NODATA 0", slr_rank, "DATA")
    except:
        gp.AddError(msgSeaLevRise)
        raise Exception

    try:
        # allocate wind and wave input
        gp.AddMessage("...determining wind and wave exposure")
        gp.Clip_analysis(WW3_Pts, aoi_prj, WW3_Pts_clip, "")
        gp.Project_management(WW3_Pts_clip, WW3_Pts_prj, projection)
        WW3_Pts_prj = AddField(WW3_Pts_prj, "PT_ID", "LONG", "0", "0")
        gp.CalculateField_management(WW3_Pts_prj, "PT_ID", "!FID!", "PYTHON")
        gp.CostAllocation_sa(WW3_Pts_prj, costsurf_e, costa_ww3, "", "", "PT_ID", "", "")
        Count_WW3Pts = gp.GetCount_management(WW3_Pts_prj)
        WW3List = numpy.zeros(Count_WW3Pts*80, dtype=numpy.float64)
        WW3Array = numpy.reshape(WW3List, (Count_WW3Pts,80))

        # current fetch directions
        dirCapList = ["DIR000_E", "DIR022_E", "DIR045_E", "DIR067_E", "DIR090_E", \
                      "DIR112_E", "DIR135_E", "DIR157_E", "DIR180_E", "DIR202_E", \
                      "DIR225_E", "DIR247_E", "DIR270_E", "DIR292_E", "DIR315_E", "DIR337_E"]

        gp.Mask = coast_rst
        gp.snapRaster = coast_rst
        CmbExpr = costa_ww3+";"+costdist_rc
        for i in range(0,len(dirCapList)):
            CmbExpr = CmbExpr+";"+FetchFolder+dirCapList[i]

        gp.Combine_sa(CmbExpr, fetch_cmb2)

        # list for the 16 directions (used for fetch and wind calculations)
        inp2 = [0, 22, 45, 67, 90, 112, 135, 157, 180, 202, 225, 247, 270, 292, 315, 337]
        # run through rows and assign values to an array
        cur = gp.UpdateCursor(WW3_Pts_prj)
        row = cur.Next()
        i = 0
        while row:
            for j in range(0,16):
                WW3Array[i][j] = row.GetValue("REI_V"+str(inp2[j]))
            for j in range(16,32):
                WW3Array[i][j] = row.GetValue("REI_PCT"+str(inp2[j-16]))
            for j in range(32,48):
                WW3Array[i][j] = row.GetValue("V10PCT_"+str(inp2[j-32]))
            for j in range(48,64):
                WW3Array[i][j] = row.GetValue("WavP_"+str(inp2[j-48]))
            for j in range(64,80):
                WW3Array[i][j] = row.GetValue("WavPPCT"+str(inp2[j-64]))
            cur.UpdateRow(row)
            row = cur.next()
            i = i + 1
        del row, cur
    
    except:
        gp.AddError(msgCostAlloc)
        raise Exception

    try:
        # add fields
        fetch_cmb2 = AddField(fetch_cmb2, "REI_T5", "FLOAT", "", "")
        fetch_cmb2 = AddField(fetch_cmb2, "EWO", "FLOAT", "", "")
        fetch_cmb2 = AddField(fetch_cmb2, "EWU", "FLOAT", "", "")
        fetch_cmb2 = AddField(fetch_cmb2, "WAVE_EXP", "FLOAT", "", "")
        fetch_cmb2 = AddField(fetch_cmb2, "FFILT", "SHORT", "", "")
        for i in range(0,len(dirCapList)):
            fetch_cmb2 = AddField(fetch_cmb2, dirCapList[i][:-1]+"H", "FLOAT", "", "") # wave height
            fetch_cmb2 = AddField(fetch_cmb2, dirCapList[i][:-1]+"T", "FLOAT", "", "") # wave period

        # wave power from fetch not WW3
        cur = gp.UpdateCursor(fetch_cmb2)
        row = cur.Next()
        while row:
            WW3_rowIndex = row.GetValue("COSTA_WW3")

            # reassign FFILT values
            count = 0
            for i in range(0,len(dirCapList)):
                if int(row.GetValue(dirCapList[i])) >= FetchDistThresh:
                    count = count + 1
            if count == 0 or count == 1:
                row.SetValue("FFILT", 0) # unexposed
            else:
                row.SetValue("FFILT", 1) # exposed

            # wave height and period calcs
            HList = numpy.zeros(16, dtype=numpy.float64)
            TList = numpy.zeros(16, dtype=numpy.float64)

            F = []
            for k in range(0,16):
                F.append(row.GetValue(dirCapList[k])) # create fetch vector (F)
                if WW3Array[WW3_rowIndex][k+32] <> 0.0:
                    Ftild = ((9.81*row.GetValue(dirCapList[k]))/(WW3Array[WW3_rowIndex][k+32]**2)) # Ftild=g.F/U^2
                    Hinf = ((0.24*(WW3Array[WW3_rowIndex][k+32]**2))/9.81) # Hinf=0.24U^2/g
                    Tinf = ((7.69*WW3Array[WW3_rowIndex][k+32])/9.81) # Tinf=7.69U/g
                    dtild = 9.81*AvgD /(WW3Array[WW3_rowIndex][k+32]**2) # dtild=g*d/U^2
                    HList[k] = Hinf*(numpy.tanh(0.343*dtild**1.14)*numpy.tanh(0.000414*Ftild**0.79/numpy.tanh(0.343*dtild**1.14)))**0.572 # wave height
                    TList[k] = Tinf*(numpy.tanh(0.1*dtild**2.01)*numpy.tanh(0.000000277*Ftild**1.45/numpy.tanh(0.1*dtild**2.01)))**0.187 # wave period
                    
            # ocean wave exposure
            # fetch heavyside step function Hf
            Hf = numpy.array([1.0 for i in range(16)])
            out = numpy.nonzero(numpy.array(F)<50000) # fetch filter of 50km
            out = out[0]
            Hf[out] = 0.0

            PoWave = numpy.array(WW3Array[WW3_rowIndex][48:64]) # WavP_ column
            Owp = numpy.array(WW3Array[WW3_rowIndex][64:80]) # WavP_PCT_ column
            Ewo = (numpy.sum(Hf*PoWave*Owp))*(row.GetValue("FFILT")) # ocean wave exposure output

            # wind and wave exposure
            PoWind = numpy.zeros(16, dtype=numpy.float64)
            for ii in range(16):
                if TList[ii] <> 0.0:
                    k = iterativek(2*numpy.pi/TList[ii], AvgD, 9.81)
                    L = 2.0*numpy.pi/k            
                    n = 0.5*(1+(2.0*k*AvgD/numpy.sinh(2.0*k*AvgD)))
                    C = L/TList[ii]
                    Cg = C*n
                    PoWind[ii] = (0.125*9.81*0.5*HList[ii]**2*TList[ii]*Cg)

            # Oup is array of wind speed occurence used in REI
            Oup = numpy.array(WW3Array[WW3_rowIndex][16:32]) # REI_PCT column
            Ewu = numpy.sum(numpy.array(PoWind)*Oup)

            #Ew is wave exposure output for the segment
            Ew = max(Ewo,Ewu) # valid ONLY for EXPOSED cells (NOT for SHELTERED segments)

            # REI (average top 5% wind speed)
            REI_Top5 = 0.0
            for j in range(0,16):
                # REI = speed (v) * pct * fetch
                REI_Top5 = REI_Top5 + float((WW3Array[WW3_rowIndex][j])*(WW3Array[WW3_rowIndex][j+16])*(row.GetValue(dirCapList[j])))
              
            row.SetValue("REI_T5", REI_Top5)
            row.SetValue("EWO", Ewo)
            row.SetValue("EWU", Ewu)
           
            if row.GetValue("FFILT") == 1: # exposed
                row.SetValue("WAVE_EXP", Ew)
            else: # sheltered
                row.SetValue("WAVE_EXP", Ewu)                

            # add wave height and period values to 'fetch_cmb2' attribute table
            for k in range(0,len(dirCapList)):
                row.SetValue(dirCapList[k][:-1]+"H", HList[k])
                row.SetValue(dirCapList[k][:-1]+"T", TList[k])

            cur.UpdateRow(row)
            row = cur.next()
        del row, cur

    except:
        gp.AddError(msgWindWaveExposure)
        raise Exception

    try:
        WindExpList = []
        WaveExpList = []
        if comarg:
            SurgeList = []
            
        cur = gp.UpdateCursor(fetch_cmb2)
        row = cur.Next()
        while row:
            CellCount = int(row.GetValue("COUNT"))
            for i in range(CellCount):
                WindExpList.append(row.GetValue("REI_T5"))
            if comarg:
                for i in range(CellCount):
                    SurgeList.append(row.GetValue("COSTDIST_RC"))  
            for i in range(CellCount):
                WaveExpList.append(row.GetValue("WAVE_EXP"))
                    
            cur.UpdateRow(row)
            row = cur.next()
        del row, cur

        fetch_cmb2 = AddField(fetch_cmb2, "WIND_RANK", "LONG", "", "")
        fetch_cmb2 = AddField(fetch_cmb2, "WAVE_RANK", "LONG", "", "")
        WindExpPctList = getPercentiles(WindExpList)
        WaveExpPctList = getPercentiles(WaveExpList)
        if comarg:
            fetch_cmb2 = AddField(fetch_cmb2, "SURGE_RANK", "LONG", "", "")
            SurgePctList = getPercentiles(SurgeList)

        cur = gp.UpdateCursor(fetch_cmb2)
        row = cur.Next()
        while row:
            # wind ranks
            REI_T5 = row.GetValue("REI_T5")
            if REI_T5 < WindExpPctList[0]:
                row.SetValue("WIND_RANK", 1)
            elif REI_T5 >= WindExpPctList[0] and REI_T5 < WindExpPctList[1]:
                row.SetValue("WIND_RANK", 2)
            elif REI_T5 >= WindExpPctList[1] and REI_T5 <= WindExpPctList[3]:
                row.SetValue("WIND_RANK", 3)
            elif REI_T5 >= WindExpPctList[3] and REI_T5 <= WindExpPctList[4]:
                row.SetValue("WIND_RANK", 4)
            elif REI_T5 > WindExpPctList[4]:
                row.SetValue("WIND_RANK", 5)

            # wave ranks
            WavePower = row.GetValue("WAVE_EXP")
            if WavePower < WaveExpPctList[0]:
                row.SetValue("WAVE_RANK", 1)
            elif WavePower >= WaveExpPctList[0] and WavePower < WaveExpPctList[1]:
                row.SetValue("WAVE_RANK", 2)
            elif WavePower >= WaveExpPctList[1] and WavePower <= WaveExpPctList[3]:
                row.SetValue("WAVE_RANK", 3)
            elif WavePower >= WaveExpPctList[3] and WavePower <= WaveExpPctList[4]:
                row.SetValue("WAVE_RANK", 4)
            else:
                row.SetValue("WAVE_RANK", 5)

            # dist to shelf ranks                
            if comarg:
                DistShelf = row.GetValue("COSTDIST_RC")
                if DistShelf < SurgePctList[0]:
                    row.SetValue("SURGE_RANK", 1)
                elif DistShelf >= SurgePctList[0] and DistShelf < SurgePctList[1]:
                    row.SetValue("SURGE_RANK", 2)
                elif DistShelf >= SurgePctList[1] and DistShelf <= SurgePctList[3]:
                    row.SetValue("SURGE_RANK", 3)
                elif DistShelf >= SurgePctList[3] and DistShelf <= SurgePctList[4]:
                    row.SetValue("SURGE_RANK", 4)
                else:
                    row.SetValue("SURGE_RANK", 5)

            cur.UpdateRow(row)
            row = cur.next()
        del row, cur

        gp.Lookup_sa(fetch_cmb2, "WIND_RANK", wind_rank)
        gp.Lookup_sa(fetch_cmb2, "WAVE_RANK", wave_rank)
        gp.Lookup_sa(fetch_cmb2, "FFILT", ffilt)
        if comarg:
            gp.Lookup_sa(fetch_cmb2, "SURGE_RANK", surge_rank)
    except:
        gp.AddError(msgRankingWWS)
        raise Exception

    try:
        # combine various index rasters
        gp.AddMessage("\nCombining results and generating outputs...")    
        CmbExpr = ffilt+";"+wind_rank+";"+wave_rank+";"+relief_rc
        if HabDirectory:
            for i in range(0,len(HabLyrAbbrevList)):
                habLower = HabLyrAbbrevList[i].lower()
                CmbExpr = CmbExpr+";"+habPath+"\\"+habLower+"_rc"
        if geomorphology:
            CmbExpr = CmbExpr+";"+gmorph_rc
        if structPoly:
            CmbExpr = CmbExpr+";"+structure
        if comarg:
            CmbExpr = CmbExpr+";"+surge_rank
        if SeaLevRise:
            CmbExpr = CmbExpr+";"+slr_rank
        gp.Combine_sa(CmbExpr, exp_index)
        
    except:
        gp.AddError(msgCombineIndex)
        raise Exception


    try:
        if globalPop:
            gp.AddMessage("...extracting coastal population")
            gp.ProjectRaster_management(globalPop, pop_prj, projection, "BILINEAR", "250", "", "", "")
            gp.ExtractByMask_sa(pop_prj, exp_index, coast_pop)
            gp.Reclassify_sa(coast_pop, "VALUE", "0 NODATA", coast_pop_rc, "DATA")
            gp.RasterToPoint_conversion(coast_pop_rc, coast_pop_Pts)

            costPopList = []
            cur = gp.UpdateCursor(coast_pop_Pts)
            row = cur.Next()
            while row:
                if row.GetValue("GRID_CODE") > 0:
                    costPopList.append(row.GetValue("GRID_CODE"))
                cur.UpdateRow(row)
                row = cur.next()
            del row, cur

            # creates a list for breaks (10, 25, 50, 75, 90)
            coastPopList = getPercentiles(costPopList)
            coast_pop_Pts = AddField(coast_pop_Pts, "POP_BREAK", "SHORT", "", "")
            coast_pop_Pts = AddField(coast_pop_Pts, "POP_RANGE", "TEXT", "30", "")
            coast_pop_Pts = AddField(coast_pop_Pts, "VAL_BREAKS", "TEXT", "50", "")

            cur = gp.UpdateCursor(coast_pop_Pts, "", "", "POP_BREAK; POP_RANGE; VAL_BREAKS; GRID_CODE")
            row = cur.Next()
            while row:
                if row.GRID_CODE < coastPopList[1]:
                    row.SetValue("POP_BREAK", 1)
                    row.SetValue("POP_RANGE", "< 25th Pctile")
                    row.SetValue("VAL_BREAKS", "Population < "+str(int(coastPopList[1]))+" People")
                if row.GRID_CODE >= coastPopList[1] and row.GRID_CODE <= coastPopList[2]:
                    row.SetValue("POP_BREAK", 2)
                    row.SetValue("POP_RANGE", "25-50th Pctile")
                    row.SetValue("VAL_BREAKS", str(int(coastPopList[1]))+" <= Population < "+str(int(coastPopList[2]))+" People")
                if row.GRID_CODE >= coastPopList[2] and row.GRID_CODE <= coastPopList[3]:
                    row.SetValue("POP_BREAK", 3)
                    row.SetValue("POP_RANGE", "50-75th Pctile")
                    row.SetValue("VAL_BREAKS", str(int(coastPopList[2]))+" <= Population < "+str(int(coastPopList[3]))+" People")
                if row.GRID_CODE > coastPopList[3]:
                    row.SetValue("POP_BREAK", 4)
                    row.SetValue("POP_RANGE", "> 75th Pctile")
                    row.SetValue("VAL_BREAKS", "Population >= "+str(int(coastPopList[3]))+" People")
                cur.UpdateRow(row)
                row = cur.next()
            del row, cur
    except:
        gp.AddError(msgPopulationCalcs)
        raise Exception


    if DEM:
        ReliefList = []
        cur = gp.UpdateCursor(exp_index)
        row = cur.Next()
        while row:
            CellCount = int(row.GetValue("COUNT"))
            for i in range(CellCount):
                if row.GetValue("RELIEF_RC") <> 0:
                    ReliefList.append(row.GetValue("RELIEF_RC"))
            cur.UpdateRow(row)
            row = cur.next()
        del row, cur
        
        ReliefPctList = getPercentiles(ReliefList)
        exp_index = AddField(exp_index, "RELF_RANK", "SHORT", "", "")

    if geomorphology:
        exp_index = AddField(exp_index, "GMRPH_RANK", "SHORT", "", "")
        
    try:
        # add final fields
        if HabDirectory:
            exp_index = AddField(exp_index, "HAB_RANK", "FLOAT", "", "")        
        if HabDirectory and geomorphology:
            exp_index = AddField(exp_index, "EI", "FLOAT", "", "")
        if HabDirectory and geomorphology and comarg and SeaLevRise:
            exp_index = AddField(exp_index, "II", "FLOAT", "", "")
        exp_index = AddField(exp_index, "VI", "FLOAT", "", "")
        if structPoly:
            exp_index = AddField(exp_index, "VI_WSTRUCT", "FLOAT", "", "")  

        gp.AddMessage("...computing exposure indices")
        cur = gp.UpdateCursor(exp_index)
        row = cur.Next()
        while row:
            if HabDirectory:
##            RankList4Max = []
                RankList = [9999]
                for i in range(0,len(HabLyrAbbrevList)):
                    if row.GetValue(HabLyrAbbrevList[i]+"_RC") > 0:
                        RankList.append(row.GetValue(HabLyrAbbrevList[i]+"_RC"))
                minRank = min(RankList)
                if minRank <> 9999:
##                for i in range(0,len(HabLyrAbbrevList)):
##                    RankList4Max.append(row.GetValue(HabLyrAbbrevList[i]+"_RC"))
##                    if row.GetValue(HabLyrAbbrevList[i]+"_RC") > 0:
##                        RankList.append(row.GetValue(HabLyrAbbrevList[i]+"_RC"))
##                maxRank = max(RankList4Max)
##                if maxRank > 0:
##                    sqRankList = [ ((5.0 - i)**2) for i in RankList]
##                    rankValue = ( 4.8 - ( 0.5 * ( ( ((1.5 * (5 - maxRank))**2) + ( (numpy.sum(sqRankList) - (5 - maxRank))**2))**0.5) ) )
                    row.SetValue("HAB_RANK", minRank)
                    ##row.SetValue("HAB_RANK", rankValue)
                else:
                    row.SetValue("HAB_RANK", 5)

            if geomorphology:
                if row.GetValue("GMORPH_RC") == 0:
                    row.SetValue("GMRPH_RANK", 3)
                else:
                    geomorphRank = row.GetValue("GMORPH_RC")
                    row.SetValue("GMRPH_RANK", geomorphRank)    

            if DEM:
                ReliefValue = row.GetValue("RELIEF_RC")
                if ReliefValue == 0:
                    row.SetValue("RELF_RANK", 3)
                if ReliefValue < ReliefPctList[0] and ReliefValue <> 0:
                    row.SetValue("RELF_RANK", 5)
                if ReliefValue >= ReliefPctList[0] and ReliefValue < ReliefPctList[1]:
                    row.SetValue("RELF_RANK", 4)
                if ReliefValue >= ReliefPctList[1] and ReliefValue <= ReliefPctList[3]:
                    row.SetValue("RELF_RANK", 3)
                if ReliefValue >= ReliefPctList[3] and ReliefValue <= ReliefPctList[4]:
                    row.SetValue("RELF_RANK", 2)
                if ReliefValue > ReliefPctList[4]:
                    row.SetValue("RELF_RANK", 1)

            # calculate erosian index
            if HabDirectory and geomorphology:
                EIExpr = row.GetValue("WAVE_RANK")*row.GetValue("HAB_RANK")*row.GetValue("GMRPH_RANK")
                
            # calculate inundation index
            if HabDirectory and geomorphology and comarg and SeaLevRise:
                IIExpr = row.GetValue("WIND_RANK")*row.GetValue("HAB_RANK")*row.GetValue("RELF_RANK")*row.GetValue("SURGE_RANK")*row.GetValue("SLR_RANK")
                
            # calculate vulnerability index
            VIExpr = row.GetValue("WAVE_RANK")*row.GetValue("WIND_RANK")*row.GetValue("RELF_RANK")
            VICount = 3.0

            if HabDirectory:
                VIExpr = VIExpr*row.GetValue("HAB_RANK")
                VICount += 1

            if geomorphology:
                VIExpr = VIExpr*row.GetValue("GMRPH_RANK")
                VICount += 1

            if comarg:
                VIExpr = VIExpr*row.GetValue("SURGE_RANK")
                VICount += 1
            
            if SeaLevRise:
                VIExpr = VIExpr*row.GetValue("SLR_RANK")
                VICount += 1

            # calculate various indices
            if HabDirectory and geomorphology:
                row.SetValue("EI", (((EIExpr)**0.5)/3.0))
            if HabDirectory and geomorphology and comarg and SeaLevRise:
                row.SetValue("II", (((IIExpr)**0.5)/5.0))   
            row.SetValue("VI", (((VIExpr)**0.5)/VICount))

            # subtract one from 'VI' if geomorphology rank is > 3
            if structPoly and geomorphology:
                if row.GetValue("GMRPH_RANK") > 3 and row.GetValue("STRUCTURE") == 1:
                    row.SetValue("VI_WSTRUCT", (((VIExpr)**0.5)/VICount)-1)
                else:
                    row.SetValue("VI_WSTRUCT", (((VIExpr)**0.5)/VICount))
            elif structPoly and not geomorphology:
                if row.GetValue("STRUCTURE") == 1:
                    row.SetValue("VI_WSTRUCT", (((VIExpr)**0.5)/VICount)-1)
                else:
                    row.SetValue("VI_WSTRUCT", (((VIExpr)**0.5)/VICount))                
                
            cur.UpdateRow(row)
            row = cur.next()
        del row, cur

        # create output with "VI" as only "value"
        if HabDirectory and geomorphology:
            gp.Lookup_sa(exp_index, "EI", eros_index)
        if HabDirectory and geomorphology and comarg and SeaLevRise:
            gp.Lookup_sa(exp_index, "II", inund_index)
        gp.Lookup_sa(exp_index, "VI", vuln_index)

        # delete "GMORPH_RC" and "RELIEF_RC" in attribute table
        if geomorphology:
            gp.DeleteField_management(exp_index, "GMORPH_RC")
        if DEM:
            gp.DeleteField_management(exp_index, "RELIEF_RC")

        # copy coastPoly from fetch calculator to coastal vulnerability output folder
        gp.CopyFeatures_management(coastPoly_prj, coastPoly_prjCopy, "", "0", "0", "0")
            
    except:
        gp.AddError(msgExposureIndex)
        raise Exception

    # create parameter file
    parameters.append("Script location: "+os.path.dirname(sys.argv[0])+"\\"+os.path.basename(sys.argv[0]))
    parafile = open(outputws+"\\parameters_"+now.strftime("%Y-%m-%d-%H-%M")+".txt","w") 
    parafile.writelines("COASTAL VULNERABILITY INDEX PARAMETERS\n")
    parafile.writelines("______________________________________\n\n")

    for para in parameters:
        parafile.writelines(para+"\n")
        parafile.writelines("\n")
    parafile.close()

    # delete superfluous intermediate data
    del1 = [gmorph_rst, gmorph_rc, gmorph_e, slr_rst, dem_land, relief_rc, relief_int, relief_fs, hab_merge, hab_nodata, coast_pop_rc]
    del2 = [pop_prj, WW3_Pts_prj, WW3_Pts_clip, costdist_rc, costdist, costd_alloc, costa_ww3, comarg_rst, comarg_prj, fetch_cmb1]
    del3 = [WW3_Pts_lyr, aoi_lyr, comarg_lyr, ffilt, ffilt_Pts, ffilt_Pts_select, ffilt_Pts_cd, struct_e, struct_e2, struct_rst, struct_rst2]
    del4 = []
    if HabDirectory and HabLayersTable:
        del4.append(habPath)
        for i in range(0,len(HabLyrAbbrevList)):
            del4.append(habPath+"\\"+HabLyrAbbrevList[i])
            del4.append(habPath+"\\"+HabLyrAbbrevList[i]+"_fs")
            del4.append(habPath+"\\"+HabLyrAbbrevList[i]+"_rc")
    deletelist = del1 + del2 + del3 + del4
    for data in deletelist:
        if gp.exists(data):
            gp.delete_management(data)
    del gp
except Exception, ErrorDesc:
    gp.AddMessage(gp.GetMessages())